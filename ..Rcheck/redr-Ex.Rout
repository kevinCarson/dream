
R version 4.4.1 (2024-06-14) -- "Race for Your Life"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: aarch64-apple-darwin20

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "redr"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('redr')
Warning: replacing previous import ‘collapse::fdroplevels’ by ‘data.table::fdroplevels’ when loading ‘redr’
Warning: replacing previous import ‘collapse::fmatch’ by ‘fastmatch::fmatch’ when loading ‘redr’
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("om.constraint")
> ### * om.constraint
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: om.constraint
> ### Title: Compute Burt's (1992) Constraint for Ego Networks
> ### Aliases: om.constraint
> 
> ### ** Examples
> 
> 
> # For this example, we recreate the ego network provided in Burt (1992: 56):
> BurtEgoNet <- matrix(c(
+   0,1,0,0,1,1,1,
+  1,0,0,1,0,0,1,
+  0,0,0,0,0,0,1,
+  0,1,0,0,0,0,1,
+  1,0,0,0,0,0,1,
+  1,0,0,0,0,0,1,
+  1,1,1,1,1,1,0),
+  nrow = 7, ncol = 7)
> colnames(BurtEgoNet) <- rownames(BurtEgoNet) <- c("A", "B", "C", "D", "E",
+                                                  "F", "ego")
> #the constraint value for the ego replicates that provided in Burt (1992: 56)
> om.constraint(BurtEgoNet)
     A      B      C      D      E      F    ego 
0.6836 0.8395 1.0000 1.1250 1.1250 1.1250 0.4003 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("om.effective")
> ### * om.effective
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: om.effective
> ### Title: Compute Burt's (1992) Effective Size for Ego Networks from a
> ###   Sociomatrix
> ### Aliases: om.effective
> 
> ### ** Examples
> 
> # For this example, we recreate the ego network provided in Borgatti (1997):
> BorgattiEgoNet <- matrix(
+  c(0,1,0,0,0,0,0,0,1,
+    1,0,0,0,0,0,0,0,1,
+    0,0,0,1,0,0,0,0,1,
+    0,0,1,0,0,0,0,0,1,
+    0,0,0,0,0,1,0,0,1,
+   0,0,0,0,1,0,0,0,1,
+   0,0,0,0,0,0,0,1,1,
+    0,0,0,0,0,0,1,0,1,
+    1,1,1,1,1,1,1,1,0),
+  nrow = 9, ncol = 9, byrow = TRUE)
> colnames(BorgattiEgoNet) <- rownames(BorgattiEgoNet) <- c("A", "B", "C",
+                                                          "D", "E", "F",
+                                                         "G", "H", "ego")
> #the effective size value for the ego replicates that provided in Borgatti (1997)
> om.effective(BorgattiEgoNet)
  A   B   C   D   E   F   G   H ego 
  1   1   1   1   1   1   1   1   7 
> 
> # For this example, we recreate the ego network provided in Burt (1992: 56):
> BurtEgoNet <- matrix(c(
+   0,1,0,0,1,1,1,
+  1,0,0,1,0,0,1,
+  0,0,0,0,0,0,1,
+  0,1,0,0,0,0,1,
+  1,0,0,0,0,0,1,
+  1,0,0,0,0,0,1,
+  1,1,1,1,1,1,0),
+  nrow = 7, ncol = 7)
> colnames(BurtEgoNet) <- rownames(BurtEgoNet) <- c("A", "B", "C", "D", "E",
+                                                  "F", "ego")
> #the effective size value for the ego replicates that provided in Burt (1992: 56)
> om.effective(BurtEgoNet)
       A        B        C        D        E        F      ego 
2.500000 1.666667 1.000000 1.000000 1.000000 1.000000 4.666667 
> 
> 
> 
> cleanEx()
> nameEx("om.npaths")
> ### * om.npaths
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: om.npaths
> ### Title: Compute the Number of Paths of Length K
> ### Aliases: om.npaths
> 
> ### ** Examples
> 
> 
> # For this example, we generate a random one-mode graph with the sna package.
> #creating the random network with 10 actors
> set.seed(9999)
> rnet <- matrix(sample(c(0,1), 10*10, replace = TRUE, prob = c(0.8,0.2)),
+                nrow = 10, ncol = 10, byrow = TRUE)
> diag(rnet) <- 0 #setting self ties to 0
> #counting the paths of length 2
> om.npaths(rnet, k = 2)
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
 [1,]    0    2    0    0    1    0    0    2    0     1
 [2,]    0    1    1    1    1    1    0    3    2     1
 [3,]    1    0    0    0    0    1    1    0    1     0
 [4,]    0    1    1    0    0    0    0    1    0     1
 [5,]    1    1    0    0    0    1    1    0    1     0
 [6,]    1    1    1    0    0    1    1    0    1     0
 [7,]    0    0    0    0    1    0    0    2    1     1
 [8,]    0    0    0    0    0    0    0    0    0     0
 [9,]    0    0    0    0    0    0    0    0    0     0
[10,]    0    0    0    0    0    0    0    0    0     0
> #counting the paths of length 5
> om.npaths(rnet, k = 5)
      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]
 [1,]    3    7    3    1    5    4    3   11    7     5
 [2,]    4    8    4    3    5    7    4   13   11     5
 [3,]    3    4    3    1    1    4    3    4    5     2
 [4,]    1    4    2    1    3    2    1    7    4     3
 [5,]    4    7    4    1    3    5    4    8    7     4
 [6,]    4    8    5    2    4    6    4   11    9     5
 [7,]    1    1    1    1    1    2    1    3    3     1
 [8,]    0    0    0    0    0    0    0    0    0     0
 [9,]    0    0    0    0    0    0    0    0    0     0
[10,]    0    0    0    0    0    0    0    0    0     0
> 
> 
> 
> cleanEx()
> nameEx("om.pi.brokerage")
> ### * om.pi.brokerage
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: om.pi.brokerage
> ### Title: Compute Interpersonal Cultural Brokerage Based on Leal (2025)
> ### Aliases: om.pi.brokerage
> 
> ### ** Examples
> 
> 
> # For this example, we recreate Figure 3 in Leal (2025)
> LealNet <- matrix( c(
+  0,1,0,0,0,0,0,
+  1,0,1,1,0,0,0,
+  0,1,0,0,1,1,0,
+  0,1,0,0,1,0,0,
+  0,0,1,1,0,0,0,
+  0,0,1,0,0,0,1,
+  0,0,0,0,0,1,0),
+  nrow = 7, ncol = 7, byrow = TRUE)
> 
> colnames(LealNet) <- rownames(LealNet) <- c("A", "B", "C","D",
+                                            "E", "F", "G")
> categorical_variable <- c(0,0,1,0,0,0,0)
> #These values are exactly the same as reported by Leal (2025)
> om.pi.brokerage(LealNet,
+    symmetric = TRUE,
+    g.mem = categorical_variable)
  A   B   C   D   E   F   G 
0.0 1.5 0.0 0.0 0.5 1.0 0.0 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("rem.riskset.om")
> ### * rem.riskset.om
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rem.riskset.om
> ### Title: Create Dynamic One-Mode Risk Sets for Relational Event Sequences
> ### Aliases: rem.riskset.om
> 
> ### ** Examples
> 
> # A random one-mode relational event sequence
> events <- data.table::data.table(time = 1:18,
+                                 eventID = 1:18,
+                                 sender = c("A", "B", "C",
+                                            "A", "D", "E",
+                                            "F", "B", "A",
+                                            "F", "D", "B",
+                                            "G", "B", "D",
+                                           "H", "A", "D"),
+                                target = c("B", "C", "D",
+                                           "E", "A", "F",
+                                           "D", "A", "C",
+                                           "G", "B", "C",
+                                           "H", "J", "A",
+                                           "F", "C", "B"))
> 
> # Creating a one-mode relational risk set with p = 1.00 (all true events) and 5 controls
> eventSet <- rem.riskset.om(data = events,
+                       time = events$time,
+                       eventID = events$eventID,
+                       sender = events$sender,
+                       receiver = events$target,
+                       p_samplingobserved = 1.00,
+                       n_controls = 5,
+                       seed = 9999)
> 
> # Creating a event-dependent one-mode relational risk set with p = 1.00 (all
> # true events) and 3 controls based upon the past 5 events prior to the current event.
> events$timeseq <- 1:nrow(events)
> eventSetT <- rem.riskset.om(data = events,
+                        time = events$time,
+                        eventID = events$eventID,
+                        sender = events$sender,
+                        receiver = events$target,
+                        p_samplingobserved = 1.00,
+                        time_dependent = TRUE,
+                        timeDV = events$timeseq,
+                        timeDif = 5,
+                        n_controls = 3,
+                        seed = 9999)
> 
> 
> 
> cleanEx()
> nameEx("rem.riskset.tm")
> ### * rem.riskset.tm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rem.riskset.tm
> ### Title: Create Dynamic Two-Mode Risk Sets for Relational Event Sequences
> ### Aliases: rem.riskset.tm
> 
> ### ** Examples
> 
> 
> data("WikiEvent2018.first100k")
> WikiEvent2018.first100k$time <- as.numeric(WikiEvent2018.first100k$time)
> ### Creating the EventSet By Employing Case-Control Sampling With M = 10 and
> ### Sampling from the Observed Event Sequence with P = 0.01
> EventSet <- rem.riskset.tm(
+   data = WikiEvent2018.first100k, # The Event Dataset
+   time = WikiEvent2018.first100k$time, # The Time Variable
+   eventID = WikiEvent2018.first100k$eventID, # The Event Sequence Variable
+   sender = WikiEvent2018.first100k$user, # The Sender Variable
+   receiver = WikiEvent2018.first100k$article, # The Receiver Variable
+   p_samplingobserved = 0.01, # The Probability of Selection
+   n_controls = 10, # The Number of Controls to Sample from the Full Risk Set
+   seed = 9999) # The Seed for Replication
> 
> 
> ### Creating A New EventSet with more observed events and less control events
> ### Sampling from the Observed Event Sequence with P = 0.10
> ### Employing Case-Control Sampling With M = 2
> EventSet1 <- rem.riskset.tm(
+   data = WikiEvent2018.first100k, # The Event Dataset
+   time = WikiEvent2018.first100k$time, # The Time Variable
+   eventID = WikiEvent2018.first100k$eventID, # The Event Sequence Variable
+   sender = WikiEvent2018.first100k$user, # The Sender Variable
+   receiver = WikiEvent2018.first100k$article, # The Receiver Variable
+   p_samplingobserved = 0.02, # The Probability of Selection
+   n_controls = 2, # The Number of Controls to Sample from the Full Risk Set
+   seed = 9999) # The Seed for Replication
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("rem.simulate")
> ### * rem.simulate
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rem.simulate
> ### Title: Simulate A One-Mode Random Relational Event Sequence
> ### Aliases: rem.simulate
> 
> ### ** Examples
> 
> #Creating a random relational sequence with 5 actors and 25 events
> rem1<- rem.simulate(n_actors = 25,
+                      n_events = 1000,
+                      inertia = TRUE,
+                      inertia_p = 0.12,
+                      recip = TRUE,
+                      recip_p = 0.08,
+                      sender_outdegree = TRUE,
+                      sender_outdegree_p = 0.09,
+                      target_indegree = TRUE,
+                      target_indegree_p = 0.05,
+                      assort = TRUE,
+                      assort_p = -0.01,
+                      trans_trips = TRUE,
+                      trans_trips_p = 0.09,
+                      three_cycles = TRUE,
+                      three_cycles_p = 0.04,
+                      starting_events = NULL,
+                      returnStats = TRUE)
> rem1
      eventID sender target inertia reciprocity sender_outdegree
        <num>  <int>  <int>   <num>       <num>            <num>
   1:       1      6     10       0           0                0
   2:       2      5     25       0           0                0
   3:       3     11     21       0           0                0
   4:       4     22     14       0           0                0
   5:       5     17      9       0           0                0
  ---                                                           
 996:     996      5      8       5           0               44
 997:     997     12     15       1           2               35
 998:     998     23     22       1           2               38
 999:     999     24      6       2           2               38
1000:    1000     17     13       1           3               36
      target_indegree assort trans_trip three_cycles
                <num>  <num>      <num>        <num>
   1:               0      0          0            0
   2:               0      0          0            0
   3:               0      0          0            0
   4:               0      0          0            0
   5:               0      0          0            0
  ---                                               
 996:              42   1848         90           95
 997:              40   1400         66           63
 998:              40   1520         69           65
 999:              37   1406         52           66
1000:              39   1404         58           71
> 
> #Creating a random relational sequence with 100 actors and 1000 events with
> #only inertia and reciprocity
> rem2 <- rem.simulate(n_actors = 100,
+                      n_events = 1000,
+                      inertia = TRUE,
+                      inertia_p = 0.12,
+                      recip = TRUE,
+                      recip_p = 0.08,
+                      returnStats = TRUE)
> rem2
      eventID sender target inertia reciprocity
        <num>  <int>  <int>   <num>       <num>
   1:       1     79     35       0           0
   2:       2      4     92       0           0
   3:       3     51     46       0           0
   4:       4     58     86       0           0
   5:       5     84     94       0           0
  ---                                          
 996:     996     75     83       0           0
 997:     997     87     92       0           0
 998:     998     97     66       0           0
 999:     999     87     42       0           0
1000:    1000     29     80       0           0
> 
> #Creating a random relational sequence based on the starting sequence with
> #only inertia and reciprocity
> rem3 <- rem.simulate(n_actors = 100, #does not matter can be any value, this is
+                                     #overridden by the starting event sequence
+                     n_events = 100,
+                     inertia = TRUE,
+                     inertia_p = 0.12,
+                     recip = TRUE,
+                     recip_p = 0.08,
+                     #a random starting event sequence
+                     starting_events = matrix(c(1:10, 10:1),
+                     nrow = 10, ncol = 2,  byrow = FALSE),
+                     returnStats = TRUE)
> rem3
     eventID sender target inertia reciprocity
       <int>  <int>  <int>   <num>       <num>
  1:       1      1     10       0           0
  2:       2      2      9       0           0
  3:       3      3      8       0           0
  4:       4      4      7       0           0
  5:       5      5      6       0           0
  6:       6      6      5       0           1
  7:       7      7      4       0           1
  8:       8      8      3       0           1
  9:       9      9      2       0           1
 10:      10     10      1       0           1
 11:      11      1      7       0           0
 12:      12      5      6       1           1
 13:      13      6      9       0           0
 14:      14     10      1       1           1
 15:      15      3      1       0           0
 16:      16      5      7       0           0
 17:      17      1     10       1           2
 18:      18      9      4       0           0
 19:      19      4      8       0           0
 20:      20      6     10       0           0
 21:      21     10      1       2           2
 22:      22      3      9       0           0
 23:      23      3      8       1           1
 24:      24      1     10       2           3
 25:      25      8      5       0           0
 26:      26     10      6       0           1
 27:      27      7      1       0           1
 28:      28      2     10       0           0
 29:      29      4      2       0           0
 30:      30     10      1       3           3
 31:      31      3      8       2           1
 32:      32      3      2       0           0
 33:      33      5      6       2           1
 34:      34      5      6       3           1
 35:      35      7      2       0           0
 36:      36      8      4       0           1
 37:      37      1      3       0           1
 38:      38      3      8       3           1
 39:      39      6      9       1           0
 40:      40      9      5       0           0
 41:      41      6      5       1           4
 42:      42      9      6       0           2
 43:      43      9      6       1           2
 44:      44      5     10       0           0
 45:      45      1      9       0           0
 46:      46      2      9       1           1
 47:      47      5     10       1           0
 48:      48      6      9       2           2
 49:      49     10      3       0           0
 50:      50      6      5       2           4
 51:      51      3      5       0           0
 52:      52      9      6       2           3
 53:      53     10      8       0           0
 54:      54     10      3       1           0
 55:      55      4      3       0           0
 56:      56      8      9       0           0
 57:      57      6      9       3           3
 58:      58      7      9       0           0
 59:      59      2      9       2           1
 60:      60      6     10       1           1
 61:      61      6      3       0           0
 62:      62     10      2       0           1
 63:      63      1     10       3           4
 64:      64      2      9       3           1
 65:      65      7      6       0           0
 66:      66     10      2       1           1
 67:      67      7      4       1           1
 68:      68      6      7       0           1
 69:      69      8      4       1           1
 70:      70      1      2       0           0
 71:      71      8      4       2           1
 72:      72      2      4       0           1
 73:      73     10      5       0           2
 74:      74      3      5       1           0
 75:      75      6      4       0           0
 76:      76      1     10       4           4
 77:      77      2      1       0           1
 78:      78     10      7       0           0
 79:      79      1      2       1           1
 80:      80      9     10       0           0
 81:      81      7      3       0           0
 82:      82      6      9       4           3
 83:      83      8      7       0           0
 84:      84      3      9       1           0
 85:      85      7      3       1           0
 86:      86      4      8       1           3
 87:      87      2      7       0           1
 88:      88      6      4       1           0
 89:      89      3      2       1           0
 90:      90      4      7       1           2
 91:      91      8      4       3           2
 92:      92      2      6       0           0
 93:      93      3      8       4           1
 94:      94      4      3       1           0
 95:      95      8      2       0           0
 96:      96      3     10       0           2
 97:      97      9      8       0           1
 98:      98     10      7       1           0
 99:      99      6      2       0           1
100:     100     10      1       4           5
     eventID sender target inertia reciprocity
> 
> 
> 
> cleanEx()
> nameEx("rem.stat.ISP")
> ### * rem.stat.ISP
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rem.stat.ISP
> ### Title: Compute Incoming Shared Partner Statistic for Relational Event
> ###   Sequences
> ### Aliases: rem.stat.ISP
> 
> ### ** Examples
> 
> events <- data.table::data.table(time = 1:18,
+                                 eventID = 1:18,
+                                 sender = c("A", "B", "C",
+                                            "A", "D", "E",
+                                            "F", "B", "A",
+                                            "F", "D", "B",
+                                            "G", "B", "D",
+                                           "H", "A", "D"),
+                                target = c("B", "C", "D",
+                                           "E", "A", "F",
+                                           "D", "A", "C",
+                                           "G", "B", "C",
+                                           "H", "J", "A",
+                                           "F", "C", "B"))
> 
> eventSet <- rem.riskset.om(data = events,
+                       time = events$time,
+                       eventID = events$eventID,
+                       sender = events$sender,
+                       receiver = events$target,
+                       p_samplingobserved = 1.00,
+                       n_controls = 1,
+                       seed = 9999)
> 
> # Computing Incoming Shared Partners Statistic without the sliding windows framework
> eventSet$ISP <- rem.stat.ISP(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_sender = events$sender, # variable (column) name that contains the sender variable
+    observed_receiver = events$target, # variable (column) name that contains the receiver variable
+    processed_time = eventSet$time,
+    processed_sender = eventSet$sender,
+    processed_receiver = eventSet$receiver,
+    halflife = 2, #halflife parameter
+    dyadic_weight = 0,
+    Lerneretal_2013 = FALSE)
> 
> # Computing Incoming Shared Partners Statistic with the sliding windows framework
> eventSet$ISP_SW <- rem.stat.ISP(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_sender = events$sender, # variable (column) name that contains the sender variable
+    observed_receiver = events$target, # variable (column) name that contains the receiver variable
+    processed_time = eventSet$time,
+    processed_sender = eventSet$sender,
+    processed_receiver = eventSet$receiver,
+    halflife = 2, #halflife parameter
+    processed_seqIDs = eventSet$sequenceID,
+    dyadic_weight = 0,
+    sliding_window = TRUE,
+    Lerneretal_2013 = FALSE)
Setting up data structure for the sliding windows framework.......
> 
> #The results with and without the sliding windows are the same (see correlation below).
> #Using the sliding windows method is recommended when the data are 'big' so
> #that memory allotment is more efficient.
> cor(eventSet$ISP , eventSet$ISP_SW)
[1] 1
> 
> # Computing Reciprocity Statistics with the counts of events being returned
> eventSet$ISPC <- rem.stat.ISP(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_sender = events$sender, # variable (column) name that contains the sender variable
+    observed_receiver = events$target, # variable (column) name that contains the receiver variable
+    processed_time = eventSet$time,
+    processed_sender = eventSet$sender,
+    processed_receiver = eventSet$receiver,
+    halflife = 2, #halflife parameter
+    dyadic_weight = 0,
+    sliding_window = FALSE,
+    counts = TRUE,
+    Lerneretal_2013 = FALSE)
> 
> cbind(eventSet$ISP,
+      eventSet$ISP_SW,
+      eventSet$ISPC)
            [,1]       [,2] [,3]
 [1,] 0.00000000 0.00000000    0
 [2,] 0.00000000 0.00000000    0
 [3,] 0.00000000 0.00000000    0
 [4,] 0.00000000 0.00000000    0
 [5,] 0.00000000 0.00000000    0
 [6,] 0.00000000 0.00000000    0
 [7,] 0.00000000 0.00000000    0
 [8,] 0.00000000 0.00000000    0
 [9,] 0.00000000 0.00000000    0
[10,] 0.00000000 0.00000000    0
[11,] 0.00000000 0.00000000    0
[12,] 0.00000000 0.00000000    0
[13,] 0.00000000 0.00000000    0
[14,] 0.00000000 0.00000000    0
[15,] 0.00000000 0.00000000    0
[16,] 0.25000000 0.25000000    1
[17,] 0.00000000 0.00000000    0
[18,] 0.00000000 0.00000000    0
[19,] 0.17677670 0.17677670    1
[20,] 0.00000000 0.00000000    0
[21,] 0.12500000 0.12500000    1
[22,] 0.08838835 0.08838835    1
[23,] 0.00000000 0.00000000    0
[24,] 0.00000000 0.00000000    0
[25,] 0.00000000 0.00000000    0
[26,] 0.00000000 0.00000000    0
[27,] 0.00000000 0.00000000    0
[28,] 0.00000000 0.00000000    0
[29,] 0.00000000 0.00000000    0
[30,] 0.00000000 0.00000000    0
[31,] 0.00000000 0.00000000    0
[32,] 0.08975879 0.08975879    1
[33,] 0.00000000 0.00000000    0
[34,] 0.00000000 0.00000000    0
[35,] 0.00000000 0.00000000    0
> 
> 
> 
> cleanEx()
> nameEx("rem.stat.ITP")
> ### * rem.stat.ITP
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rem.stat.ITP
> ### Title: Compute Incoming Two Path Statistic for Relational Event
> ###   Sequences
> ### Aliases: rem.stat.ITP
> 
> ### ** Examples
> 
> events <- data.table::data.table(time = 1:18,
+                                 eventID = 1:18,
+                                 sender = c("A", "B", "C",
+                                            "A", "D", "E",
+                                            "F", "B", "A",
+                                            "F", "D", "B",
+                                            "G", "B", "D",
+                                           "H", "A", "D"),
+                                target = c("B", "C", "D",
+                                           "E", "A", "F",
+                                           "D", "A", "C",
+                                           "G", "B", "C",
+                                           "H", "J", "A",
+                                           "F", "C", "B"))
> 
> eventSet <- rem.riskset.om(data = events,
+                       time = events$time,
+                       eventID = events$eventID,
+                       sender = events$sender,
+                       receiver = events$target,
+                       p_samplingobserved = 1.00,
+                       n_controls = 1,
+                       seed = 9999)
> 
> # Computing Incoming Two Paths Statistics without the sliding windows framework
> eventSet$ITP <- rem.stat.ITP(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_sender = events$sender, # variable (column) name that contains the sender variable
+    observed_receiver = events$target, # variable (column) name that contains the receiver variable
+    processed_time = eventSet$time,
+    processed_sender = eventSet$sender,
+    processed_receiver = eventSet$receiver,
+    halflife = 2, #halflife parameter
+    dyadic_weight = 0,
+    Lerneretal_2013 = FALSE)
> 
> # Computing Incoming Two Paths Statistics with the sliding windows framework
> eventSet$ITP_SW <- rem.stat.ITP(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_sender = events$sender, # variable (column) name that contains the sender variable
+    observed_receiver = events$target, # variable (column) name that contains the receiver variable
+    processed_time = eventSet$time,
+    processed_sender = eventSet$sender,
+    processed_receiver = eventSet$receiver,
+    halflife = 2, #halflife parameter
+    processed_seqIDs = eventSet$sequenceID,
+    dyadic_weight = 0,
+    sliding_window = TRUE,
+    Lerneretal_2013 = FALSE)
Setting up data structure for the sliding windows framework.......
> 
> #The results with and without the sliding windows are the same (see correlation below).
> #Using the sliding windows method is recommended when the data are 'big' so
> #that memory allotment is more efficient.
> cor(eventSet$ITP, eventSet$ITP_SW)
[1] 1
> 
> # Computing Reciprocity Statistics with the counts of events being returned
> eventSet$ITPC <- rem.stat.ITP(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_sender = events$sender, # variable (column) name that contains the sender variable
+    observed_receiver = events$target, # variable (column) name that contains the receiver variable
+    processed_time = eventSet$time,
+    processed_sender = eventSet$sender,
+    processed_receiver = eventSet$receiver,
+    halflife = 2, #halflife parameter
+    dyadic_weight = 0,
+    sliding_window = FALSE,
+    counts = TRUE,
+    Lerneretal_2013 = FALSE)
> 
> cbind(eventSet$ITP,
+      eventSet$ITP_SW,
+      eventSet$ITPC)
            [,1]       [,2] [,3]
 [1,] 0.00000000 0.00000000    0
 [2,] 0.00000000 0.00000000    0
 [3,] 0.00000000 0.00000000    0
 [4,] 0.00000000 0.00000000    0
 [5,] 0.00000000 0.00000000    0
 [6,] 0.00000000 0.00000000    0
 [7,] 0.00000000 0.00000000    0
 [8,] 0.00000000 0.00000000    0
 [9,] 0.42044821 0.42044821    1
[10,] 0.00000000 0.00000000    0
[11,] 0.00000000 0.00000000    0
[12,] 0.00000000 0.00000000    0
[13,] 0.00000000 0.00000000    0
[14,] 0.00000000 0.00000000    0
[15,] 0.00000000 0.00000000    0
[16,] 0.17677670 0.17677670    1
[17,] 0.00000000 0.00000000    0
[18,] 0.00000000 0.00000000    0
[19,] 0.08838835 0.08838835    1
[20,] 0.05255603 0.05255603    1
[21,] 0.00000000 0.00000000    0
[22,] 0.17677670 0.17677670    1
[23,] 0.00000000 0.00000000    0
[24,] 0.00000000 0.00000000    0
[25,] 0.00000000 0.00000000    0
[26,] 0.00000000 0.00000000    0
[27,] 0.00000000 0.00000000    0
[28,] 0.04419417 0.04419417    1
[29,] 0.00000000 0.00000000    0
[30,] 0.21022410 0.21022410    1
[31,] 0.00000000 0.00000000    0
[32,] 0.06346905 0.06346905    1
[33,] 0.02627801 0.02627801    1
[34,] 0.02668545 0.02668545    1
[35,] 0.00000000 0.00000000    0
> 
> 
> 
> cleanEx()
> nameEx("rem.stat.OSP")
> ### * rem.stat.OSP
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rem.stat.OSP
> ### Title: Compute Outgoing Shared Partner Statistic for Relational Event
> ###   Sequences
> ### Aliases: rem.stat.OSP
> 
> ### ** Examples
> 
> events <- data.table::data.table(time = 1:18,
+                                 eventID = 1:18,
+                                 sender = c("A", "B", "C",
+                                            "A", "D", "E",
+                                            "F", "B", "A",
+                                            "F", "D", "B",
+                                            "G", "B", "D",
+                                           "H", "A", "D"),
+                                target = c("B", "C", "D",
+                                           "E", "A", "F",
+                                           "D", "A", "C",
+                                           "G", "B", "C",
+                                           "H", "J", "A",
+                                           "F", "C", "B"))
> 
> eventSet <- rem.riskset.om(data = events,
+                       time = events$time,
+                       eventID = events$eventID,
+                       sender = events$sender,
+                       receiver = events$target,
+                       p_samplingobserved = 1.00,
+                       n_controls = 1,
+                       seed = 9999)
> 
> # Computing Outgoing Shared Partners Statistics without the sliding windows framework
> eventSet$OSP <- rem.stat.OSP(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_sender = events$sender, # variable (column) name that contains the sender variable
+    observed_receiver = events$target, # variable (column) name that contains the receiver variable
+    processed_time = eventSet$time,
+    processed_sender = eventSet$sender,
+    processed_receiver = eventSet$receiver,
+    halflife = 2, #halflife parameter
+    dyadic_weight = 0,
+    Lerneretal_2013 = FALSE)
> 
> # Computing Outgoing Shared Partners Statistics with the sliding windows framework
> eventSet$OSP_SW <- rem.stat.OSP(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_sender = events$sender, # variable (column) name that contains the sender variable
+    observed_receiver = events$target, # variable (column) name that contains the receiver variable
+    processed_time = eventSet$time,
+    processed_sender = eventSet$sender,
+    processed_receiver = eventSet$receiver,
+    halflife = 2, #halflife parameter
+    processed_seqIDs = eventSet$sequenceID,
+    dyadic_weight = 0,
+    sliding_window = TRUE,
+    Lerneretal_2013 = FALSE)
Setting up data structure for the sliding windows framework.......
> 
> #The results with and without the sliding windows are the same (see correlation below).
> #Using the sliding windows method is recommended when the data are 'big' so
> #that memory allotment is more efficient.
> cor(eventSet$OSP , eventSet$OSP_SW)
[1] 1
> 
> # Computing  Outgoing Shared Partners Statistics with the counts of events being returned
> eventSet$OSP_C <- rem.stat.OSP(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_sender = events$sender, # variable (column) name that contains the sender variable
+    observed_receiver = events$target, # variable (column) name that contains the receiver variable
+    processed_time = eventSet$time,
+    processed_sender = eventSet$sender,
+    processed_receiver = eventSet$receiver,
+    halflife = 2, #halflife parameter
+    dyadic_weight = 0,
+    sliding_window = FALSE,
+    counts = TRUE,
+    Lerneretal_2013 = FALSE)
> 
> cbind(eventSet$OSP,
+      eventSet$OSP_SW,
+      eventSet$OSP_C)
            [,1]       [,2] [,3]
 [1,] 0.00000000 0.00000000    0
 [2,] 0.00000000 0.00000000    0
 [3,] 0.00000000 0.00000000    0
 [4,] 0.00000000 0.00000000    0
 [5,] 0.00000000 0.00000000    0
 [6,] 0.00000000 0.00000000    0
 [7,] 0.00000000 0.00000000    0
 [8,] 0.00000000 0.00000000    0
 [9,] 0.00000000 0.00000000    0
[10,] 0.00000000 0.00000000    0
[11,] 0.00000000 0.00000000    0
[12,] 0.00000000 0.00000000    0
[13,] 0.00000000 0.00000000    0
[14,] 0.00000000 0.00000000    0
[15,] 0.00000000 0.00000000    0
[16,] 0.00000000 0.00000000    0
[17,] 0.00000000 0.00000000    0
[18,] 0.00000000 0.00000000    0
[19,] 0.29730178 0.29730178    1
[20,] 0.21022410 0.21022410    1
[21,] 0.21022410 0.21022410    1
[22,] 0.00000000 0.00000000    0
[23,] 0.00000000 0.00000000    0
[24,] 0.00000000 0.00000000    0
[25,] 0.00000000 0.00000000    0
[26,] 0.00000000 0.00000000    0
[27,] 0.00000000 0.00000000    0
[28,] 0.04419417 0.04419417    1
[29,] 0.00000000 0.00000000    0
[30,] 0.00000000 0.00000000    0
[31,] 0.00000000 0.00000000    0
[32,] 0.00000000 0.00000000    0
[33,] 0.00000000 0.00000000    0
[34,] 0.10674179 0.10674179    1
[35,] 0.00000000 0.00000000    0
> 
> 
> 
> cleanEx()
> nameEx("rem.stat.OTP")
> ### * rem.stat.OTP
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rem.stat.OTP
> ### Title: Compute Outgoing Two Path Statistic for Relational Event
> ###   Sequences
> ### Aliases: rem.stat.OTP
> 
> ### ** Examples
> 
> events <- data.table::data.table(time = 1:18,
+                                 eventID = 1:18,
+                                 sender = c("A", "B", "C",
+                                            "A", "D", "E",
+                                            "F", "B", "A",
+                                            "F", "D", "B",
+                                            "G", "B", "D",
+                                           "H", "A", "D"),
+                                target = c("B", "C", "D",
+                                           "E", "A", "F",
+                                           "D", "A", "C",
+                                           "G", "B", "C",
+                                           "H", "J", "A",
+                                           "F", "C", "B"))
> 
> eventSet <- rem.riskset.om(data = events,
+                       time = events$time,
+                       eventID = events$eventID,
+                       sender = events$sender,
+                       receiver = events$target,
+                       p_samplingobserved = 1.00,
+                       n_controls = 1,
+                       seed = 9999)
> 
> # Computing Outgoing Two Paths Statistics without the sliding windows framework
> eventSet$OTP <- rem.stat.OTP(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_sender = events$sender, # variable (column) name that contains the sender variable
+    observed_receiver = events$target, # variable (column) name that contains the receiver variable
+    processed_time = eventSet$time,
+    processed_sender = eventSet$sender,
+    processed_receiver = eventSet$receiver,
+    halflife = 2, #halflife parameter
+    dyadic_weight = 0,
+    Lerneretal_2013 = FALSE)
> 
> # Computing Outgoing Two Paths Statistics with the sliding windows framework
> eventSet$OTP_SW <- rem.stat.OTP(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_sender = events$sender, # variable (column) name that contains the sender variable
+    observed_receiver = events$target, # variable (column) name that contains the receiver variable
+    processed_time = eventSet$time,
+    processed_sender = eventSet$sender,
+    processed_receiver = eventSet$receiver,
+    halflife = 2, #halflife parameter
+    processed_seqIDs = eventSet$sequenceID,
+    dyadic_weight = 0,
+    sliding_window = TRUE,
+    Lerneretal_2013 = FALSE)
Setting up data structure for the sliding windows framework.......
> 
> #The results with and without the sliding windows are the same (see correlation below).
> #Using the sliding windows method is recommended when the data are 'big' so
> #that memory allotment is more efficient.
> cor(eventSet$OTP , eventSet$OTP_SW)
[1] 1
> 
> # Computing Reciprocity Statistics with the counts of events being returned
> eventSet$OTPC <- rem.stat.OTP(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_sender = events$sender, # variable (column) name that contains the sender variable
+    observed_receiver = events$target, # variable (column) name that contains the receiver variable
+    processed_time = eventSet$time,
+    processed_sender = eventSet$sender,
+    processed_receiver = eventSet$receiver,
+    halflife = 2, #halflife parameter
+    dyadic_weight = 0,
+    sliding_window = FALSE,
+    counts = TRUE,
+    Lerneretal_2013 = FALSE)
> 
> cbind(eventSet$OTP,
+      eventSet$OTP_SW,
+      eventSet$OTPC)
            [,1]       [,2] [,3]
 [1,] 0.00000000 0.00000000    0
 [2,] 0.00000000 0.00000000    0
 [3,] 0.00000000 0.00000000    0
 [4,] 0.00000000 0.00000000    0
 [5,] 0.00000000 0.00000000    0
 [6,] 0.00000000 0.00000000    0
 [7,] 0.42044821 0.42044821    1
 [8,] 0.00000000 0.00000000    0
 [9,] 0.00000000 0.00000000    0
[10,] 0.00000000 0.00000000    0
[11,] 0.50000000 0.50000000    1
[12,] 0.00000000 0.00000000    0
[13,] 0.00000000 0.00000000    0
[14,] 0.00000000 0.00000000    0
[15,] 0.00000000 0.00000000    0
[16,] 0.07432544 0.07432544    1
[17,] 0.00000000 0.00000000    0
[18,] 0.00000000 0.00000000    0
[19,] 0.08838835 0.08838835    1
[20,] 0.06250000 0.06250000    1
[21,] 0.00000000 0.00000000    0
[22,] 0.29730178 0.29730178    1
[23,] 0.07432544 0.07432544    1
[24,] 0.00000000 0.00000000    0
[25,] 0.12500000 0.12500000    1
[26,] 0.00000000 0.00000000    0
[27,] 0.00000000 0.00000000    0
[28,] 0.14865089 0.14865089    1
[29,] 0.00000000 0.00000000    0
[30,] 0.00000000 0.00000000    0
[31,] 0.03125000 0.03125000    1
[32,] 0.02668545 0.02668545    1
[33,] 0.00000000 0.00000000    0
[34,] 0.03173453 0.03173453    1
[35,] 0.00000000 0.00000000    0
> 
> 
> 
> cleanEx()
> nameEx("rem.stat.cycle4")
> ### * rem.stat.cycle4
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rem.stat.cycle4
> ### Title: Compute The Four-Cycles Statistic for Two-Mode Relational Event
> ###   Sequences
> ### Aliases: rem.stat.cycle4
> 
> ### ** Examples
> 
> data("WikiEvent2018.first100k")
> WikiEvent2018 <- WikiEvent2018.first100k[1:10000,] #the first ten thousand events
> WikiEvent2018$time <- as.numeric(WikiEvent2018$time) #making the variable numeric
> ### Creating the EventSet By Employing Case-Control Sampling With M = 5 and
> ### Sampling from the Observed Event Sequence with P = 0.01
> EventSet <- rem.riskset.tm(
+  data = WikiEvent2018, # The Event Dataset
+  time = WikiEvent2018$time, # The Time Variable
+  eventID = WikiEvent2018$eventID, # The Event Sequence Variable
+  sender = WikiEvent2018$user, # The Sender Variable
+  receiver = WikiEvent2018$article, # The Receiver Variable
+  p_samplingobserved = 0.01, # The Probability of Selection
+  n_controls = 5, # The Number of Controls to Sample from the Full Risk Set
+  seed = 9999) # The Seed for Replication
> 
> #### Estimating the Four-Cycle Statistic Without the Sliding Windows Framework
> EventSet$fourcycle <- rem.stat.cycle4(
+    observed_time = WikiEvent2018$time,
+    observed_sender = WikiEvent2018$user,
+    observed_receiver = WikiEvent2018$article,
+    processed_time = EventSet$time,
+    processed_sender = EventSet$sender,
+    processed_receiver = EventSet$receiver,
+    halflife = 2.592e+09, #halflife parameter
+    dyadic_weight = 0,
+    Lerneretal_2013 = FALSE)
> 
> #### Estimating the Four-Cycle Statistic With the Sliding Windows Framework
> EventSet$cycle4SW <- rem.stat.cycle4(
+    observed_time = WikiEvent2018$time,
+    observed_sender = WikiEvent2018$user,
+    observed_receiver = WikiEvent2018$article,
+    processed_time = EventSet$time,
+    processed_sender = EventSet$sender,
+    processed_receiver = EventSet$receiver,
+    processed_seqIDs = EventSet$sequenceID,
+    halflife = 2.592e+09, #halflife parameter
+    dyadic_weight = 0,
+    sliding_window = TRUE,
+    Lerneretal_2013 = FALSE)
Setting up data structure for the sliding windows framework.......
> 
> #The results with and without the sliding windows are the same (see correlation below).
> #Using the sliding windows method is recommended when the data are 'big' so
> #that memory allotment is more efficient.
> cor(EventSet$fourcycle, EventSet$cycle4SW)
[1] 1
> 
> #### Estimating the Four-Cycle Statistic  with the Counts of Events Returned
> EventSet$cycle4C <- rem.stat.cycle4(
+    observed_time = WikiEvent2018$time,
+    observed_sender = WikiEvent2018$user,
+    observed_receiver = WikiEvent2018$article,
+    processed_time = EventSet$time,
+    processed_sender = EventSet$sender,
+    processed_receiver = EventSet$receiver,
+    processed_seqIDs = EventSet$sequenceID,
+    halflife = 2.592e+09, #halflife parameter
+    dyadic_weight = 0,
+    sliding_window = FALSE,
+    counts = TRUE,
+    Lerneretal_2013 = FALSE)
> 
> cbind(EventSet$fourcycle,
+      EventSet$cycle4SW,
+      EventSet$cycle4C)
             [,1]       [,2] [,3]
  [1,] 0.00000000 0.00000000    0
  [2,] 0.00000000 0.00000000    0
  [3,] 0.00000000 0.00000000    0
  [4,] 0.00000000 0.00000000    0
  [5,] 0.00000000 0.00000000    0
  [6,] 0.00000000 0.00000000    0
  [7,] 0.00000000 0.00000000    0
  [8,] 0.00000000 0.00000000    0
  [9,] 0.00000000 0.00000000    0
 [10,] 0.00000000 0.00000000    0
 [11,] 0.62323771 0.62323771    1
 [12,] 0.00000000 0.00000000    0
 [13,] 0.00000000 0.00000000    0
 [14,] 0.00000000 0.00000000    0
 [15,] 0.00000000 0.00000000    0
 [16,] 0.67182321 0.67182321    1
 [17,] 0.00000000 0.00000000    0
 [18,] 0.00000000 0.00000000    0
 [19,] 0.00000000 0.00000000    0
 [20,] 0.00000000 0.00000000    0
 [21,] 0.00000000 0.00000000    0
 [22,] 0.00000000 0.00000000    0
 [23,] 0.00000000 0.00000000    0
 [24,] 0.00000000 0.00000000    0
 [25,] 0.00000000 0.00000000    0
 [26,] 0.00000000 0.00000000    0
 [27,] 0.00000000 0.00000000    0
 [28,] 0.00000000 0.00000000    0
 [29,] 0.00000000 0.00000000    0
 [30,] 0.00000000 0.00000000    0
 [31,] 0.00000000 0.00000000    0
 [32,] 0.00000000 0.00000000    0
 [33,] 0.00000000 0.00000000    0
 [34,] 0.00000000 0.00000000    0
 [35,] 0.00000000 0.00000000    0
 [36,] 0.00000000 0.00000000    0
 [37,] 0.00000000 0.00000000    0
 [38,] 0.00000000 0.00000000    0
 [39,] 0.00000000 0.00000000    0
 [40,] 0.00000000 0.00000000    0
 [41,] 0.00000000 0.00000000    0
 [42,] 0.00000000 0.00000000    0
 [43,] 0.00000000 0.00000000    0
 [44,] 0.00000000 0.00000000    0
 [45,] 1.17204963 1.17204963    1
 [46,] 0.00000000 0.00000000    0
 [47,] 0.00000000 0.00000000    0
 [48,] 0.00000000 0.00000000    0
 [49,] 0.00000000 0.00000000    0
 [50,] 0.00000000 0.00000000    0
 [51,] 0.00000000 0.00000000    0
 [52,] 0.00000000 0.00000000    0
 [53,] 1.02130735 1.02130735    2
 [54,] 0.00000000 0.00000000    0
 [55,] 0.00000000 0.00000000    0
 [56,] 0.00000000 0.00000000    0
 [57,] 0.00000000 0.00000000    0
 [58,] 0.00000000 0.00000000    0
 [59,] 0.00000000 0.00000000    0
 [60,] 0.00000000 0.00000000    0
 [61,] 0.00000000 0.00000000    0
 [62,] 0.00000000 0.00000000    0
 [63,] 0.34251723 0.34251723    1
 [64,] 0.00000000 0.00000000    0
 [65,] 0.82787646 0.82787646    1
 [66,] 0.00000000 0.00000000    0
 [67,] 0.00000000 0.00000000    0
 [68,] 0.00000000 0.00000000    0
 [69,] 0.00000000 0.00000000    0
 [70,] 0.00000000 0.00000000    0
 [71,] 0.00000000 0.00000000    0
 [72,] 0.00000000 0.00000000    0
 [73,] 0.00000000 0.00000000    0
 [74,] 0.00000000 0.00000000    0
 [75,] 0.00000000 0.00000000    0
 [76,] 0.00000000 0.00000000    0
 [77,] 0.00000000 0.00000000    0
 [78,] 0.00000000 0.00000000    0
 [79,] 0.00000000 0.00000000    0
 [80,] 0.00000000 0.00000000    0
 [81,] 0.00000000 0.00000000    0
 [82,] 0.00000000 0.00000000    0
 [83,] 0.00000000 0.00000000    0
 [84,] 0.00000000 0.00000000    0
 [85,] 0.00000000 0.00000000    0
 [86,] 0.00000000 0.00000000    0
 [87,] 0.00000000 0.00000000    0
 [88,] 0.59588511 0.59588511    3
 [89,] 0.00000000 0.00000000    0
 [90,] 0.00000000 0.00000000    0
 [91,] 0.00000000 0.00000000    0
 [92,] 0.00000000 0.00000000    0
 [93,] 0.00000000 0.00000000    0
 [94,] 0.00000000 0.00000000    0
 [95,] 0.00000000 0.00000000    0
 [96,] 0.00000000 0.00000000    0
 [97,] 0.00000000 0.00000000    0
 [98,] 0.00000000 0.00000000    0
 [99,] 0.00000000 0.00000000    0
[100,] 0.00000000 0.00000000    0
[101,] 0.00000000 0.00000000    0
[102,] 0.00000000 0.00000000    0
[103,] 0.00000000 0.00000000    0
[104,] 0.00000000 0.00000000    0
[105,] 0.00000000 0.00000000    0
[106,] 0.00000000 0.00000000    0
[107,] 0.00000000 0.00000000    0
[108,] 0.00000000 0.00000000    0
[109,] 0.00000000 0.00000000    0
[110,] 0.00000000 0.00000000    0
[111,] 0.00000000 0.00000000    0
[112,] 0.00000000 0.00000000    0
[113,] 0.00000000 0.00000000    0
[114,] 0.00000000 0.00000000    0
[115,] 0.00000000 0.00000000    0
[116,] 0.00000000 0.00000000    0
[117,] 0.00000000 0.00000000    0
[118,] 0.00000000 0.00000000    0
[119,] 0.00000000 0.00000000    0
[120,] 0.00000000 0.00000000    0
[121,] 0.00000000 0.00000000    0
[122,] 0.00000000 0.00000000    0
[123,] 0.00000000 0.00000000    0
[124,] 0.00000000 0.00000000    0
[125,] 0.00000000 0.00000000    0
[126,] 0.00000000 0.00000000    0
[127,] 0.00000000 0.00000000    0
[128,] 0.00000000 0.00000000    0
[129,] 0.00000000 0.00000000    0
[130,] 0.00000000 0.00000000    0
[131,] 0.00000000 0.00000000    0
[132,] 0.68157737 0.68157737    1
[133,] 0.00000000 0.00000000    0
[134,] 0.00000000 0.00000000    0
[135,] 0.00000000 0.00000000    0
[136,] 0.00000000 0.00000000    0
[137,] 0.00000000 0.00000000    0
[138,] 0.00000000 0.00000000    0
[139,] 0.00000000 0.00000000    0
[140,] 0.00000000 0.00000000    0
[141,] 0.00000000 0.00000000    0
[142,] 0.00000000 0.00000000    0
[143,] 0.00000000 0.00000000    0
[144,] 0.00000000 0.00000000    0
[145,] 0.00000000 0.00000000    0
[146,] 0.00000000 0.00000000    0
[147,] 0.00000000 0.00000000    0
[148,] 0.00000000 0.00000000    0
[149,] 0.00000000 0.00000000    0
[150,] 0.00000000 0.00000000    0
[151,] 0.00000000 0.00000000    0
[152,] 0.00000000 0.00000000    0
[153,] 0.00000000 0.00000000    0
[154,] 0.50807536 0.50807536    1
[155,] 0.00000000 0.00000000    0
[156,] 0.00000000 0.00000000    0
[157,] 0.00000000 0.00000000    0
[158,] 0.00000000 0.00000000    0
[159,] 0.00000000 0.00000000    0
[160,] 0.00000000 0.00000000    0
[161,] 0.00000000 0.00000000    0
[162,] 0.49855678 0.49855678    1
[163,] 0.00000000 0.00000000    0
[164,] 0.00000000 0.00000000    0
[165,] 0.00000000 0.00000000    0
[166,] 0.00000000 0.00000000    0
[167,] 0.00000000 0.00000000    0
[168,] 0.00000000 0.00000000    0
[169,] 0.00000000 0.00000000    0
[170,] 0.20031010 0.20031010    2
[171,] 0.00000000 0.00000000    0
[172,] 0.00000000 0.00000000    0
[173,] 0.00000000 0.00000000    0
[174,] 0.00000000 0.00000000    0
[175,] 0.00000000 0.00000000    0
[176,] 0.00000000 0.00000000    0
[177,] 0.00000000 0.00000000    0
[178,] 0.00000000 0.00000000    0
[179,] 0.00000000 0.00000000    0
[180,] 0.00000000 0.00000000    0
[181,] 0.00000000 0.00000000    0
[182,] 0.00000000 0.00000000    0
[183,] 0.63932237 0.63932237    1
[184,] 0.00000000 0.00000000    0
[185,] 0.00000000 0.00000000    0
[186,] 0.00000000 0.00000000    0
[187,] 0.97539286 0.97539286    2
[188,] 0.00000000 0.00000000    0
[189,] 0.00000000 0.00000000    0
[190,] 0.00000000 0.00000000    0
[191,] 0.00000000 0.00000000    0
[192,] 0.00000000 0.00000000    0
[193,] 0.00000000 0.00000000    0
[194,] 0.00000000 0.00000000    0
[195,] 0.00000000 0.00000000    0
[196,] 0.00000000 0.00000000    0
[197,] 0.00000000 0.00000000    0
[198,] 0.00000000 0.00000000    0
[199,] 0.00000000 0.00000000    0
[200,] 0.00000000 0.00000000    0
[201,] 0.00000000 0.00000000    0
[202,] 0.00000000 0.00000000    0
[203,] 0.00000000 0.00000000    0
[204,] 0.00000000 0.00000000    0
[205,] 0.00000000 0.00000000    0
[206,] 0.00000000 0.00000000    0
[207,] 0.00000000 0.00000000    0
[208,] 0.00000000 0.00000000    0
[209,] 0.00000000 0.00000000    0
[210,] 0.00000000 0.00000000    0
[211,] 0.00000000 0.00000000    0
[212,] 0.00000000 0.00000000    0
[213,] 0.00000000 0.00000000    0
[214,] 0.00000000 0.00000000    0
[215,] 0.00000000 0.00000000    0
[216,] 0.00000000 0.00000000    0
[217,] 0.00000000 0.00000000    0
[218,] 0.00000000 0.00000000    0
[219,] 0.00000000 0.00000000    0
[220,] 0.00000000 0.00000000    0
[221,] 0.00000000 0.00000000    0
[222,] 0.41947026 0.41947026    1
[223,] 0.00000000 0.00000000    0
[224,] 0.00000000 0.00000000    0
[225,] 0.00000000 0.00000000    0
[226,] 0.00000000 0.00000000    0
[227,] 0.00000000 0.00000000    0
[228,] 0.00000000 0.00000000    0
[229,] 0.00000000 0.00000000    0
[230,] 0.00000000 0.00000000    0
[231,] 0.00000000 0.00000000    0
[232,] 0.00000000 0.00000000    0
[233,] 0.00000000 0.00000000    0
[234,] 0.00000000 0.00000000    0
[235,] 0.00000000 0.00000000    0
[236,] 0.00000000 0.00000000    0
[237,] 0.00000000 0.00000000    0
[238,] 0.00000000 0.00000000    0
[239,] 0.00000000 0.00000000    0
[240,] 0.00000000 0.00000000    0
[241,] 0.75045851 0.75045851    4
[242,] 0.00000000 0.00000000    0
[243,] 0.00000000 0.00000000    0
[244,] 0.00000000 0.00000000    0
[245,] 0.00000000 0.00000000    0
[246,] 0.00000000 0.00000000    0
[247,] 0.86589603 0.86589603   25
[248,] 0.00000000 0.00000000    0
[249,] 0.00000000 0.00000000    0
[250,] 0.00000000 0.00000000    0
[251,] 0.00000000 0.00000000    0
[252,] 0.00000000 0.00000000    0
[253,] 0.00000000 0.00000000    0
[254,] 0.45593181 0.45593181    2
[255,] 0.00000000 0.00000000    0
[256,] 0.00000000 0.00000000    0
[257,] 0.00000000 0.00000000    0
[258,] 0.00000000 0.00000000    0
[259,] 0.00000000 0.00000000    0
[260,] 0.00000000 0.00000000    0
[261,] 0.24723497 0.24723497    1
[262,] 0.00000000 0.00000000    0
[263,] 0.00000000 0.00000000    0
[264,] 0.00000000 0.00000000    0
[265,] 0.00000000 0.00000000    0
[266,] 0.00000000 0.00000000    0
[267,] 0.00000000 0.00000000    0
[268,] 0.35899480 0.35899480    1
[269,] 0.00000000 0.00000000    0
[270,] 0.25117843 0.25117843    1
[271,] 0.00000000 0.00000000    0
[272,] 0.00000000 0.00000000    0
[273,] 0.07462025 0.07462025    3
[274,] 0.00000000 0.00000000    0
[275,] 0.23108049 0.23108049    1
[276,] 0.00000000 0.00000000    0
[277,] 0.00000000 0.00000000    0
[278,] 0.00000000 0.00000000    0
[279,] 0.40295387 0.40295387    1
[280,] 0.00000000 0.00000000    0
[281,] 0.00000000 0.00000000    0
[282,] 0.00000000 0.00000000    0
[283,] 0.00000000 0.00000000    0
[284,] 0.00000000 0.00000000    0
[285,] 0.00000000 0.00000000    0
[286,] 0.00000000 0.00000000    0
[287,] 0.00000000 0.00000000    0
[288,] 0.20971683 0.20971683    1
[289,] 0.00000000 0.00000000    0
[290,] 0.00000000 0.00000000    0
[291,] 0.00000000 0.00000000    0
[292,] 0.00000000 0.00000000    0
[293,] 0.00000000 0.00000000    0
[294,] 0.00000000 0.00000000    0
[295,] 0.00000000 0.00000000    0
[296,] 0.00000000 0.00000000    0
[297,] 0.00000000 0.00000000    0
[298,] 0.00000000 0.00000000    0
[299,] 0.00000000 0.00000000    0
[300,] 0.00000000 0.00000000    0
[301,] 0.00000000 0.00000000    0
[302,] 0.00000000 0.00000000    0
[303,] 0.00000000 0.00000000    0
[304,] 0.00000000 0.00000000    0
[305,] 0.34524678 0.34524678    1
[306,] 0.00000000 0.00000000    0
[307,] 0.00000000 0.00000000    0
[308,] 0.00000000 0.00000000    0
[309,] 0.00000000 0.00000000    0
[310,] 0.00000000 0.00000000    0
[311,] 0.00000000 0.00000000    0
[312,] 0.00000000 0.00000000    0
[313,] 0.00000000 0.00000000    0
[314,] 0.00000000 0.00000000    0
[315,] 0.00000000 0.00000000    0
[316,] 0.00000000 0.00000000    0
[317,] 0.00000000 0.00000000    0
[318,] 0.60098879 0.60098879    1
[319,] 0.00000000 0.00000000    0
[320,] 0.00000000 0.00000000    0
[321,] 0.00000000 0.00000000    0
[322,] 0.00000000 0.00000000    0
[323,] 0.00000000 0.00000000    0
[324,] 0.00000000 0.00000000    0
[325,] 0.55135238 0.55135238    2
[326,] 0.00000000 0.00000000    0
[327,] 0.00000000 0.00000000    0
[328,] 0.00000000 0.00000000    0
[329,] 0.00000000 0.00000000    0
[330,] 0.00000000 0.00000000    0
[331,] 0.00000000 0.00000000    0
[332,] 0.00000000 0.00000000    0
[333,] 0.00000000 0.00000000    0
[334,] 0.00000000 0.00000000    0
[335,] 0.00000000 0.00000000    0
[336,] 0.00000000 0.00000000    0
[337,] 0.00000000 0.00000000    0
[338,] 0.00000000 0.00000000    0
[339,] 0.00000000 0.00000000    0
[340,] 0.00000000 0.00000000    0
[341,] 0.00000000 0.00000000    0
[342,] 0.00000000 0.00000000    0
[343,] 0.00000000 0.00000000    0
[344,] 0.12804864 0.12804864    1
[345,] 0.00000000 0.00000000    0
[346,] 0.10864792 0.10864792    3
[347,] 0.00000000 0.00000000    0
[348,] 0.00000000 0.00000000    0
[349,] 0.00000000 0.00000000    0
[350,] 0.00000000 0.00000000    0
[351,] 0.00000000 0.00000000    0
[352,] 0.00000000 0.00000000    0
[353,] 0.00000000 0.00000000    0
[354,] 0.00000000 0.00000000    0
[355,] 0.00000000 0.00000000    0
[356,] 0.00000000 0.00000000    0
[357,] 0.00000000 0.00000000    0
[358,] 0.00000000 0.00000000    0
[359,] 0.00000000 0.00000000    0
[360,] 0.00000000 0.00000000    0
[361,] 1.43725769 1.43725769    2
[362,] 0.00000000 0.00000000    0
[363,] 0.00000000 0.00000000    0
[364,] 0.00000000 0.00000000    0
[365,] 1.11213104 1.11213104   18
[366,] 0.00000000 0.00000000    0
[367,] 0.00000000 0.00000000    0
[368,] 0.00000000 0.00000000    0
[369,] 0.00000000 0.00000000    0
[370,] 0.07239491 0.07239491    1
[371,] 0.00000000 0.00000000    0
[372,] 0.00000000 0.00000000    0
[373,] 0.00000000 0.00000000    0
[374,] 0.00000000 0.00000000    0
[375,] 0.00000000 0.00000000    0
[376,] 1.48798996 1.48798996    2
[377,] 0.00000000 0.00000000    0
[378,] 0.00000000 0.00000000    0
[379,] 0.00000000 0.00000000    0
[380,] 0.00000000 0.00000000    0
[381,] 0.00000000 0.00000000    0
[382,] 0.00000000 0.00000000    0
[383,] 0.00000000 0.00000000    0
[384,] 0.00000000 0.00000000    0
[385,] 1.12407761 1.12407761    2
[386,] 0.00000000 0.00000000    0
[387,] 0.00000000 0.00000000    0
[388,] 0.00000000 0.00000000    0
[389,] 0.00000000 0.00000000    0
[390,] 0.00000000 0.00000000    0
[391,] 0.00000000 0.00000000    0
[392,] 0.00000000 0.00000000    0
[393,] 0.00000000 0.00000000    0
[394,] 0.00000000 0.00000000    0
[395,] 0.00000000 0.00000000    0
[396,] 0.00000000 0.00000000    0
[397,] 0.00000000 0.00000000    0
[398,] 0.00000000 0.00000000    0
[399,] 0.00000000 0.00000000    0
[400,] 0.00000000 0.00000000    0
[401,] 0.00000000 0.00000000    0
[402,] 0.00000000 0.00000000    0
[403,] 0.00000000 0.00000000    0
[404,] 0.00000000 0.00000000    0
[405,] 0.00000000 0.00000000    0
[406,] 0.00000000 0.00000000    0
[407,] 0.00000000 0.00000000    0
[408,] 0.00000000 0.00000000    0
[409,] 0.00000000 0.00000000    0
[410,] 0.00000000 0.00000000    0
[411,] 0.00000000 0.00000000    0
[412,] 0.00000000 0.00000000    0
[413,] 0.00000000 0.00000000    0
[414,] 0.00000000 0.00000000    0
[415,] 0.00000000 0.00000000    0
[416,] 0.00000000 0.00000000    0
[417,] 0.00000000 0.00000000    0
[418,] 0.00000000 0.00000000    0
[419,] 0.37686581 0.37686581    3
[420,] 0.00000000 0.00000000    0
[421,] 0.00000000 0.00000000    0
[422,] 0.00000000 0.00000000    0
[423,] 0.00000000 0.00000000    0
[424,] 0.00000000 0.00000000    0
[425,] 0.14670836 0.14670836    3
[426,] 0.00000000 0.00000000    0
[427,] 0.00000000 0.00000000    0
[428,] 0.00000000 0.00000000    0
[429,] 0.00000000 0.00000000    0
[430,] 0.00000000 0.00000000    0
[431,] 0.00000000 0.00000000    0
[432,] 0.00000000 0.00000000    0
[433,] 0.00000000 0.00000000    0
[434,] 0.00000000 0.00000000    0
[435,] 0.00000000 0.00000000    0
[436,] 0.00000000 0.00000000    0
[437,] 0.00000000 0.00000000    0
[438,] 0.26770156 0.26770156    2
[439,] 0.00000000 0.00000000    0
[440,] 0.00000000 0.00000000    0
[441,] 0.00000000 0.00000000    0
[442,] 0.37188781 0.37188781    5
[443,] 0.00000000 0.00000000    0
[444,] 0.00000000 0.00000000    0
[445,] 0.00000000 0.00000000    0
[446,] 0.00000000 0.00000000    0
[447,] 0.00000000 0.00000000    0
[448,] 0.24487441 0.24487441    1
[449,] 0.00000000 0.00000000    0
[450,] 0.00000000 0.00000000    0
[451,] 0.38121037 0.38121037    2
[452,] 0.00000000 0.00000000    0
[453,] 0.00000000 0.00000000    0
[454,] 0.00000000 0.00000000    0
[455,] 0.00000000 0.00000000    0
[456,] 0.00000000 0.00000000    0
[457,] 2.33000501 2.33000501    7
[458,] 0.00000000 0.00000000    0
[459,] 0.00000000 0.00000000    0
[460,] 0.00000000 0.00000000    0
[461,] 0.00000000 0.00000000    0
[462,] 0.00000000 0.00000000    0
[463,] 1.59099970 1.59099970   23
[464,] 0.00000000 0.00000000    0
[465,] 0.00000000 0.00000000    0
[466,] 0.00000000 0.00000000    0
[467,] 0.00000000 0.00000000    0
[468,] 0.00000000 0.00000000    0
[469,] 0.00000000 0.00000000    0
[470,] 0.00000000 0.00000000    0
[471,] 0.00000000 0.00000000    0
[472,] 0.00000000 0.00000000    0
[473,] 0.00000000 0.00000000    0
[474,] 0.00000000 0.00000000    0
[475,] 0.00000000 0.00000000    0
[476,] 0.00000000 0.00000000    0
[477,] 0.54159355 0.54159355   12
[478,] 0.00000000 0.00000000    0
[479,] 0.00000000 0.00000000    0
[480,] 0.00000000 0.00000000    0
[481,] 0.00000000 0.00000000    0
[482,] 0.00000000 0.00000000    0
[483,] 0.00000000 0.00000000    0
[484,] 0.00000000 0.00000000    0
[485,] 0.00000000 0.00000000    0
[486,] 0.00000000 0.00000000    0
[487,] 0.00000000 0.00000000    0
[488,] 0.00000000 0.00000000    0
[489,] 0.00000000 0.00000000    0
[490,] 0.00000000 0.00000000    0
[491,] 0.00000000 0.00000000    0
[492,] 0.00000000 0.00000000    0
[493,] 0.35106421 0.35106421    1
[494,] 0.00000000 0.00000000    0
[495,] 0.00000000 0.00000000    0
[496,] 0.33321509 0.33321509    2
[497,] 0.00000000 0.00000000    0
[498,] 0.00000000 0.00000000    0
[499,] 0.00000000 0.00000000    0
[500,] 0.00000000 0.00000000    0
[501,] 0.52673554 0.52673554    1
[502,] 0.00000000 0.00000000    0
[503,] 0.00000000 0.00000000    0
[504,] 0.00000000 0.00000000    0
[505,] 0.00000000 0.00000000    0
[506,] 0.00000000 0.00000000    0
[507,] 0.00000000 0.00000000    0
[508,] 0.00000000 0.00000000    0
[509,] 0.00000000 0.00000000    0
[510,] 0.00000000 0.00000000    0
[511,] 0.00000000 0.00000000    0
[512,] 0.00000000 0.00000000    0
[513,] 0.00000000 0.00000000    0
[514,] 0.00000000 0.00000000    0
[515,] 0.00000000 0.00000000    0
[516,] 0.00000000 0.00000000    0
[517,] 0.00000000 0.00000000    0
[518,] 0.00000000 0.00000000    0
[519,] 0.00000000 0.00000000    0
[520,] 0.00000000 0.00000000    0
[521,] 0.00000000 0.00000000    0
[522,] 0.00000000 0.00000000    0
[523,] 0.00000000 0.00000000    0
[524,] 0.00000000 0.00000000    0
[525,] 0.00000000 0.00000000    0
[526,] 0.00000000 0.00000000    0
[527,] 0.00000000 0.00000000    0
[528,] 0.00000000 0.00000000    0
[529,] 0.00000000 0.00000000    0
[530,] 0.00000000 0.00000000    0
[531,] 0.00000000 0.00000000    0
[532,] 0.00000000 0.00000000    0
[533,] 0.00000000 0.00000000    0
[534,] 0.10225525 0.10225525    4
[535,] 0.00000000 0.00000000    0
[536,] 0.00000000 0.00000000    0
[537,] 0.00000000 0.00000000    0
[538,] 0.00000000 0.00000000    0
[539,] 0.00000000 0.00000000    0
[540,] 0.00000000 0.00000000    0
[541,] 0.00000000 0.00000000    0
[542,] 0.01426050 0.01426050    1
[543,] 0.00000000 0.00000000    0
[544,] 0.00000000 0.00000000    0
[545,] 0.00000000 0.00000000    0
[546,] 0.00000000 0.00000000    0
[547,] 0.00000000 0.00000000    0
[548,] 0.00000000 0.00000000    0
[549,] 0.00000000 0.00000000    0
[550,] 0.00000000 0.00000000    0
[551,] 0.00000000 0.00000000    0
[552,] 0.00000000 0.00000000    0
[553,] 1.76669374 1.76669374   28
[554,] 0.00000000 0.00000000    0
[555,] 0.00000000 0.00000000    0
[556,] 0.00000000 0.00000000    0
[557,] 0.00000000 0.00000000    0
[558,] 0.00000000 0.00000000    0
[559,] 0.00000000 0.00000000    0
[560,] 0.00000000 0.00000000    0
[561,] 0.00000000 0.00000000    0
[562,] 0.00000000 0.00000000    0
[563,] 0.00000000 0.00000000    0
[564,] 0.00000000 0.00000000    0
[565,] 0.00000000 0.00000000    0
[566,] 0.00000000 0.00000000    0
[567,] 0.00000000 0.00000000    0
[568,] 0.00000000 0.00000000    0
[569,] 0.00000000 0.00000000    0
[570,] 0.00000000 0.00000000    0
[571,] 0.00000000 0.00000000    0
[572,] 0.00000000 0.00000000    0
[573,] 0.00000000 0.00000000    0
[574,] 0.00000000 0.00000000    0
[575,] 0.00000000 0.00000000    0
[576,] 0.00000000 0.00000000    0
[577,] 0.99926719 0.99926719    1
[578,] 0.00000000 0.00000000    0
[579,] 0.00000000 0.00000000    0
[580,] 0.00000000 0.00000000    0
[581,] 0.00000000 0.00000000    0
[582,] 0.00000000 0.00000000    0
[583,] 0.00000000 0.00000000    0
[584,] 0.00000000 0.00000000    0
[585,] 0.00000000 0.00000000    0
[586,] 0.00000000 0.00000000    0
[587,] 1.55182160 1.55182160   11
[588,] 0.00000000 0.00000000    0
[589,] 0.00000000 0.00000000    0
[590,] 0.00000000 0.00000000    0
[591,] 0.00000000 0.00000000    0
[592,] 0.00000000 0.00000000    0
[593,] 0.00000000 0.00000000    0
[594,] 0.24973691 0.24973691    1
[595,] 0.00000000 0.00000000    0
[596,] 0.00000000 0.00000000    0
[597,] 0.00000000 0.00000000    0
[598,] 0.00000000 0.00000000    0
[599,] 0.00000000 0.00000000    0
[600,] 0.00000000 0.00000000    0
> 
> 
> 
> 
> cleanEx()
> nameEx("rem.stat.dyadCut")
> ### * rem.stat.dyadCut
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rem.stat.dyadCut
> ### Title: Helper Function to Assist Researchers Finding Dyadic Weight
> ###   Cutoff Values
> ### Aliases: rem.stat.dyadCut
> 
> ### ** Examples
> 
> #To replicate the example in the details section:
> # with the Lerner et al. 2013 weighting function
> rem.stat.dyadCut(halflife = 30,
+                  timeValue = 100,
+                  timeWidth = 60,
+                  Lerneretal_2013 = TRUE)
You are employing this function to find the corresponding dyadic cutoff value
          for temporal relevancy. The timeValue, timeWidth, and halflife parameters must
          all be in the same measurement unit (e.g., hours, days).

          We hope you are providing the correct values...
[1] 0.005776227
> 
> # without the Lerner et al. 2013 weighting function
> rem.stat.dyadCut(halflife = 30,
+                  timeValue = 100,
+                  timeWidth = 60,
+                  Lerneretal_2013 = FALSE)
You are employing this function to find the corresponding dyadic cutoff value
          for temporal relevancy. The timeValue, timeWidth, and halflife parameters must
          all be in the same measurement unit (e.g., hours, days).

          We hope you are providing the correct values...
[1] 0.25
> 
> # A result to test the function (should come out to 0.50)
> rem.stat.dyadCut(halflife = 30,
+                  timeValue = 100,
+                  timeWidth = 30,
+                  Lerneretal_2013 = FALSE)
You are employing this function to find the corresponding dyadic cutoff value
          for temporal relevancy. The timeValue, timeWidth, and halflife parameters must
          all be in the same measurement unit (e.g., hours, days).

          We hope you are providing the correct values...
[1] 0.5
> 
> 
> # Replicating Lerner and Lomi (2020):
> #"We set T1/2 to 30 days so that an event counts as (close to) one in the very next instant of time,
> #it counts as 1/2 one month later, it counts as 1/4 two months after the event, and so on. To reduce
> #the memory consumption needed to store the network of past events, we set a dyadic weight to
> #zero if its value drops below 0.01. If a single event occurred in some dyad this would happen after
> #6.64×T1/2, that is after more than half a year." (Lerner and Lomi 2020: 104).
> 
> # Based upon Lerner and Lomi (2020: 104), the result should be around 0.01. Since the
> # time values are in milliseconds, we have to change all measurements into milliseconds
> rem.stat.dyadCut(halflife = (30*24*60*60*1000), #30 days in milliseconds
+                 #the first value in the Lerner and Lomi (2020) WikiEvent 2018 dataset
+                 timeValue = 979686793000,
+                 timeWidth = (6.64*30*24*60*60*1000), #Based upon the paper
+                 #using the Lerner and Lomi (2020) weighting function
+                 Lerneretal_2013 = FALSE)
You are employing this function to find the corresponding dyadic cutoff value
          for temporal relevancy. The timeValue, timeWidth, and halflife parameters must
          all be in the same measurement unit (e.g., hours, days).

          We hope you are providing the correct values...
[1] 0.01002676
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("rem.stat.indegreeR")
> ### * rem.stat.indegreeR
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rem.stat.indegreeR
> ### Title: Compute Indegree Statistic for Event Receivers in Relational
> ###   Event Sequences
> ### Aliases: rem.stat.indegreeR
> 
> ### ** Examples
> 
> events <- data.table::data.table(time = 1:18,
+                                 eventID = 1:18,
+                                 sender = c("A", "B", "C",
+                                            "A", "D", "E",
+                                            "F", "B", "A",
+                                            "F", "D", "B",
+                                            "G", "B", "D",
+                                           "H", "A", "D"),
+                                target = c("B", "C", "D",
+                                           "E", "A", "F",
+                                           "D", "A", "C",
+                                           "G", "B", "C",
+                                           "H", "J", "A",
+                                           "F", "C", "B"))
> 
> eventSet <- rem.riskset.om(data = events,
+                       time = events$time,
+                       eventID = events$eventID,
+                       sender = events$sender,
+                       receiver = events$target,
+                       p_samplingobserved = 1.00,
+                       n_controls = 1,
+                       seed = 9999)
> 
> # Computing Target Indegree Statistics without the sliding windows framework
> eventSet$target_indegree <- rem.stat.indegreeR(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_receiver = events$target, # variable (column) name that contains the receiver variable
+    processed_time = eventSet$time,
+    processed_receiver = eventSet$receiver,
+    halflife = 2, #halflife parameter
+    dyadic_weight = 0,
+    Lerneretal_2013 = FALSE)
> 
> # Computing Target Indegree Statistics with the sliding windows framework
> eventSet$target_indegreeSW <- rem.stat.indegreeR(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_receiver = events$target, # variable (column) name that contains the receiver variable
+    processed_time = eventSet$time,
+    processed_receiver = eventSet$receiver,
+    halflife = 2, #halflife parameter
+    processed_seqIDs = eventSet$sequenceID,
+    dyadic_weight = 0,
+    sliding_window = TRUE,
+    Lerneretal_2013 = FALSE)
> 
> #The results with and without the sliding windows are the same (see correlation below).
> #Using the sliding windows method is recommended when the data are 'big' so
> #that memory allotment is more efficient.
> cor(eventSet$target_indegree , eventSet$target_indegreeSW )
[1] 1
> 
> # Computing Target Indegree Statistics with the counts of events being returned
> eventSet$target_indegreeC <- rem.stat.indegreeR(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_receiver = events$target, # variable (column) name that contains the receiver variable
+    processed_time = eventSet$time,
+    processed_receiver = eventSet$receiver,
+    halflife = 2, #halflife parameter
+    processed_seqIDs = eventSet$sequenceID,
+    dyadic_weight = 0,
+    sliding_window = TRUE,
+    Lerneretal_2013 = FALSE,
+    counts = TRUE)
> 
> cbind(eventSet$target_indegree,
+      eventSet$target_indegreeSW,
+      eventSet$target_indegreeC)
            [,1]       [,2] [,3]
 [1,] 0.00000000 0.00000000    0
 [2,] 0.00000000 0.00000000    0
 [3,] 0.70710678 0.70710678    1
 [4,] 0.00000000 0.00000000    0
 [5,] 0.00000000 0.00000000    0
 [6,] 0.00000000 0.00000000    0
 [7,] 0.00000000 0.00000000    0
 [8,] 0.00000000 0.00000000    0
 [9,] 0.35355339 0.35355339    1
[10,] 0.00000000 0.00000000    0
[11,] 0.50000000 0.50000000    1
[12,] 0.25000000 0.25000000    1
[13,] 0.35355339 0.35355339    1
[14,] 0.35355339 0.35355339    1
[15,] 0.35355339 0.35355339    1
[16,] 0.08838835 0.08838835    1
[17,] 0.95710678 0.95710678    2
[18,] 0.00000000 0.00000000    0
[19,] 0.25000000 0.25000000    1
[20,] 0.03125000 0.03125000    1
[21,] 0.17677670 0.17677670    1
[22,] 0.38480339 0.38480339    2
[23,] 0.22097087 0.22097087    2
[24,] 0.00000000 0.00000000    0
[25,] 0.04419417 0.04419417    1
[26,] 0.00000000 0.00000000    0
[27,] 0.69240170 0.69240170    3
[28,] 0.11963835 0.11963835    2
[29,] 0.25781250 0.25781250    2
[30,] 0.03125000 0.03125000    1
[31,] 0.05524272 0.05524272    2
[32,] 0.24480097 0.24480097    3
[33,] 0.01104854 0.01104854    1
[34,] 0.09115048 0.09115048    2
[35,] 0.17677670 0.17677670    1
> 
> 
> 
> cleanEx()
> nameEx("rem.stat.indegreeS")
> ### * rem.stat.indegreeS
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rem.stat.indegreeS
> ### Title: Compute Indegree Statistic for Event Senders in Relational Event
> ###   Sequences
> ### Aliases: rem.stat.indegreeS
> 
> ### ** Examples
> 
> events <- data.table::data.table(time = 1:18,
+                                 eventID = 1:18,
+                                 sender = c("A", "B", "C",
+                                            "A", "D", "E",
+                                            "F", "B", "A",
+                                            "F", "D", "B",
+                                            "G", "B", "D",
+                                           "H", "A", "D"),
+                                target = c("B", "C", "D",
+                                           "E", "A", "F",
+                                           "D", "A", "C",
+                                           "G", "B", "C",
+                                           "H", "J", "A",
+                                           "F", "C", "B"))
> 
> eventSet <- rem.riskset.om(data = events,
+                       time = events$time,
+                       eventID = events$eventID,
+                       sender = events$sender,
+                       receiver = events$target,
+                       p_samplingobserved = 1.00,
+                       n_controls = 1,
+                       seed = 9999)
> 
> # Computing Sender Indegree Statistics without the sliding windows framework
> eventSet$sender.indegree <- rem.stat.indegreeS(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_sender = events$sender, # variable (column) name that contains the sender variable
+    observed_receiver = events$target, # variable (column) name that contains the receiver variable
+    processed_time = eventSet$time,
+    processed_sender = eventSet$sender,
+    processed_receiver = eventSet$receiver,
+    halflife = 2, #halflife parameter
+    dyadic_weight = 0,
+    Lerneretal_2013 = FALSE)
> 
> # Computing Sender Indegree Statistics with the sliding windows framework
> eventSet$sender.indegree.SW <- rem.stat.indegreeS(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_sender = events$sender, # variable (column) name that contains the sender variable
+    observed_receiver = events$target, # variable (column) name that contains the receiver variable
+    processed_time = eventSet$time,
+    processed_sender = eventSet$sender,
+    processed_receiver = eventSet$receiver,
+    halflife = 2, #halflife parameter
+    processed_seqIDs = eventSet$sequenceID,
+    dyadic_weight = 0,
+    sliding_window = TRUE,
+    Lerneretal_2013 = FALSE)
> 
> #The results with and without the sliding windows are the same (see correlation below).
> #Using the sliding windows method is recommended when the data are 'big' so
> #that memory allotment is more efficient.
> cor(eventSet$sender.indegree.SW,eventSet$sender.indegree)
[1] 1
> 
> # Computing Sender Indegree Statistics with the counts of events being returned
> eventSet$sender.indegreeC <- rem.stat.indegreeS(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_sender = events$sender, # variable (column) name that contains the sender variable
+    observed_receiver = events$target, # variable (column) name that contains the receiver variable
+    processed_time = eventSet$time,
+    processed_sender = eventSet$sender,
+    processed_receiver = eventSet$receiver,
+    halflife = 2, #halflife parameter
+    dyadic_weight = 0,
+    Lerneretal_2013 = FALSE,
+    counts = TRUE)
> 
> cbind(eventSet$sender.indegree.SW,
+      eventSet$sender.indegree,
+      eventSet$sender.indegreeC)
            [,1]       [,2] [,3]
 [1,] 0.00000000 0.00000000    0
 [2,] 0.70710678 0.70710678    1
 [3,] 0.70710678 0.70710678    1
 [4,] 0.70710678 0.70710678    1
 [5,] 0.00000000 0.00000000    0
 [6,] 0.00000000 0.00000000    0
 [7,] 0.50000000 0.50000000    1
 [8,] 0.50000000 0.50000000    1
 [9,] 0.00000000 0.00000000    0
[10,] 0.50000000 0.50000000    1
[11,] 0.70710678 0.70710678    1
[12,] 0.70710678 0.70710678    1
[13,] 0.70710678 0.70710678    1
[14,] 0.08838835 0.08838835    1
[15,] 0.12500000 0.12500000    1
[16,] 0.95710678 0.95710678    1
[17,] 0.35355339 0.35355339    1
[18,] 0.25000000 0.25000000    1
[19,] 0.44194174 0.44194174    1
[20,] 0.31250000 0.31250000    1
[21,] 0.08838835 0.08838835    1
[22,] 0.72920387 0.72920387    1
[23,] 0.38480339 0.38480339    1
[24,] 0.35355339 0.35355339    1
[25,] 0.97920387 0.97920387    1
[26,] 0.36460193 0.36460193    1
[27,] 0.69240170 0.69240170    1
[28,] 0.07812500 0.07812500    1
[29,] 0.11963835 0.11963835    1
[30,] 0.35355339 0.35355339    1
[31,] 0.18230097 0.18230097    1
[32,] 0.55981917 0.55981917    1
[33,] 0.55981917 0.55981917    1
[34,] 0.02762136 0.02762136    1
[35,] 0.02762136 0.02762136    1
> 
> 
> 
> cleanEx()
> nameEx("rem.stat.outdegreeR")
> ### * rem.stat.outdegreeR
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rem.stat.outdegreeR
> ### Title: Compute Outdegree Statistic for Event Receivers in Relational
> ###   Event Sequences
> ### Aliases: rem.stat.outdegreeR
> 
> ### ** Examples
> 
> events <- data.table::data.table(time = 1:18,
+                                 eventID = 1:18,
+                                 sender = c("A", "B", "C",
+                                            "A", "D", "E",
+                                            "F", "B", "A",
+                                            "F", "D", "B",
+                                            "G", "B", "D",
+                                           "H", "A", "D"),
+                                target = c("B", "C", "D",
+                                           "E", "A", "F",
+                                           "D", "A", "C",
+                                           "G", "B", "C",
+                                           "H", "J", "A",
+                                           "F", "C", "B"))
> 
> eventSet <- rem.riskset.om(data = events,
+                       time = events$time,
+                       eventID = events$eventID,
+                       sender = events$sender,
+                       receiver = events$target,
+                       p_samplingobserved = 1.00,
+                       n_controls = 1,
+                       seed = 9999)
> 
> # Computing Target Outdegree Statistics without the sliding windows framework
> eventSet$target_outdegree <- rem.stat.outdegreeR(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_sender = events$sender, # variable (column) name that contains the sender variable
+    observed_receiver = events$target, # variable (column) name that contains the receiver variable
+    processed_time = eventSet$time,
+    processed_sender = eventSet$sender,
+    processed_receiver = eventSet$receiver,
+    halflife = 2, #halflife parameter
+    dyadic_weight = 0,
+    Lerneretal_2013 = FALSE)
> 
> # Computing Target Outdegree Statistics with the sliding windows framework
> eventSet$target_outdegreeSW <- rem.stat.outdegreeR(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_sender = events$sender, # variable (column) name that contains the sender variable
+    observed_receiver = events$target, # variable (column) name that contains the receiver variable
+    processed_time = eventSet$time,
+    processed_sender = eventSet$sender,
+    processed_receiver = eventSet$receiver,
+    halflife = 2, #halflife parameter
+    processed_seqIDs = eventSet$sequenceID,
+    dyadic_weight = 0,
+    sliding_window = TRUE,
+    Lerneretal_2013 = FALSE)
> 
> #The results with and without the sliding windows are the same (see correlation below).
> #Using the sliding windows method is recommended when the data are 'big' so
> #that memory allotment is more efficient.
> cor(eventSet$target_outdegreeSW , eventSet$target_outdegree)
[1] 1
> 
> # Computing  Target Outdegree Statistic with the counts of events being returned
> eventSet$target_outdegreeC <- rem.stat.outdegreeR(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_sender = events$sender, # variable (column) name that contains the sender variable
+    observed_receiver = events$target, # variable (column) name that contains the receiver variable
+    processed_time = eventSet$time,
+    processed_sender = eventSet$sender,
+    processed_receiver = eventSet$receiver,
+    halflife = 2, #halflife parameter
+    dyadic_weight = 0,
+    sliding_window = FALSE,
+    counts = TRUE,
+    Lerneretal_2013 = FALSE)
> 
> cbind(eventSet$target_outdegree,
+      eventSet$target_outdegreeSW,
+      eventSet$target_outdegreeC)
            [,1]       [,2] [,3]
 [1,] 0.00000000 0.00000000    0
 [2,] 0.00000000 0.00000000    0
 [3,] 0.70710678 0.70710678    1
 [4,] 0.00000000 0.00000000    0
 [5,] 0.50000000 0.50000000    1
 [6,] 0.00000000 0.00000000    0
 [7,] 0.35355339 0.35355339    1
 [8,] 0.95710678 0.95710678    1
 [9,] 0.00000000 0.00000000    0
[10,] 0.00000000 0.00000000    0
[11,] 0.70710678 0.70710678    1
[12,] 0.50000000 0.50000000    1
[13,] 0.47855339 0.47855339    1
[14,] 0.33838835 0.33838835    1
[15,] 0.35355339 0.35355339    1
[16,] 0.12500000 0.12500000    1
[17,] 0.23927670 0.23927670    1
[18,] 0.00000000 0.00000000    0
[19,] 0.56250000 0.56250000    1
[20,] 0.39774756 0.39774756    1
[21,] 0.00000000 0.00000000    0
[22,] 0.04419417 0.04419417    1
[23,] 0.12500000 0.12500000    1
[24,] 0.00000000 0.00000000    0
[25,] 0.00000000 0.00000000    0
[26,] 0.00000000 0.00000000    0
[27,] 0.70710678 0.70710678    1
[28,] 0.15490959 0.15490959    1
[29,] 0.23927670 0.23927670    1
[30,] 0.16919417 0.16919417    1
[31,] 0.01104854 0.01104854    1
[32,] 0.00781250 0.00781250    1
[33,] 0.11963835 0.11963835    1
[34,] 0.41015625 0.41015625    1
[35,] 0.41015625 0.41015625    1
> 
> 
> 
> cleanEx()
> nameEx("rem.stat.outdegreeS")
> ### * rem.stat.outdegreeS
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rem.stat.outdegreeS
> ### Title: Compute Outdegree Statistic for Event Senders in Relational
> ###   Event Sequences
> ### Aliases: rem.stat.outdegreeS
> 
> ### ** Examples
> 
> events <- data.table::data.table(time = 1:18,
+                                 eventID = 1:18,
+                                 sender = c("A", "B", "C",
+                                            "A", "D", "E",
+                                            "F", "B", "A",
+                                            "F", "D", "B",
+                                            "G", "B", "D",
+                                           "H", "A", "D"),
+                                target = c("B", "C", "D",
+                                           "E", "A", "F",
+                                           "D", "A", "C",
+                                           "G", "B", "C",
+                                           "H", "J", "A",
+                                           "F", "C", "B"))
> 
> eventSet <- rem.riskset.om(data = events,
+                       time = events$time,
+                       eventID = events$eventID,
+                       sender = events$sender,
+                       receiver = events$target,
+                       p_samplingobserved = 1.00,
+                       n_controls = 1,
+                       seed = 9999)
> 
> # Computing Sender Outdegree Statistics without the sliding windows framework
> eventSet$sender_outdegree <- rem.stat.outdegreeS(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_sender = events$sender, # variable (column) name that contains the sender variable
+    processed_time = eventSet$time,
+    processed_sender = eventSet$sender,
+    halflife = 2, #halflife parameter
+    dyadic_weight = 0,
+    Lerneretal_2013 = FALSE)
> 
> # Computing Sender Outdegree Statistics with the sliding windows framework
> eventSet$sender_outdegreeSW <- rem.stat.outdegreeS(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_sender = events$sender, # variable (column) name that contains the sender variable
+    processed_time = eventSet$time,
+    processed_sender = eventSet$sender,
+    halflife = 2, #halflife parameter
+    processed_seqIDs = eventSet$sequenceID,
+    dyadic_weight = 0,
+    sliding_window = TRUE,
+    Lerneretal_2013 = FALSE)
> 
> #The results with and without the sliding windows are the same (see correlation below).
> #Using the sliding windows method is recommended when the data are 'big' so
> #that memory allotment is more efficient.
> cor(eventSet$sender_outdegreeSW , eventSet$sender_outdegree)
[1] 1
> 
> # Computing  Sender Outdegree Statistic with the counts of events being returned
> eventSet$sender_outdegreeC <- rem.stat.outdegreeS(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_sender = events$sender, # variable (column) name that contains the sender variable
+    processed_time = eventSet$time,
+    processed_sender = eventSet$sender,
+    halflife = 2, #halflife parameter
+    dyadic_weight = 0,
+    sliding_window = FALSE,
+    counts = TRUE,
+    Lerneretal_2013 = FALSE)
> 
> cbind(eventSet$sender_outdegree,
+      eventSet$sender_outdegreeSW,
+      eventSet$sender_outdegreeC)
            [,1]       [,2] [,3]
 [1,] 0.00000000 0.00000000    0
 [2,] 0.00000000 0.00000000    0
 [3,] 0.70710678 0.70710678    1
 [4,] 0.00000000 0.00000000    0
 [5,] 0.00000000 0.00000000    0
 [6,] 0.35355339 0.35355339    1
 [7,] 0.35355339 0.35355339    1
 [8,] 0.00000000 0.00000000    0
 [9,] 0.35355339 0.35355339    1
[10,] 0.00000000 0.00000000    0
[11,] 0.67677670 0.67677670    2
[12,] 0.00000000 0.00000000    0
[13,] 0.70710678 0.70710678    1
[14,] 0.12500000 0.12500000    1
[15,] 0.35355339 0.35355339    1
[16,] 0.23927670 0.23927670    2
[17,] 0.23927670 0.23927670    2
[18,] 0.35355339 0.35355339    1
[19,] 0.56250000 0.56250000    2
[20,] 0.12500000 0.12500000    1
[21,] 0.39774756 0.39774756    2
[22,] 0.28125000 0.28125000    2
[23,] 0.04419417 0.04419417    1
[24,] 0.00000000 0.00000000    0
[25,] 0.08838835 0.08838835    1
[26,] 0.64062500 0.64062500    3
[27,] 0.21907524 0.21907524    3
[28,] 0.28125000 0.28125000    2
[29,] 0.04419417 0.04419417    1
[30,] 0.00000000 0.00000000    0
[31,] 0.00000000 0.00000000    0
[32,] 0.07745479 0.07745479    3
[33,] 0.70710678 0.70710678    1
[34,] 0.45299028 0.45299028    3
[35,] 0.00000000 0.00000000    0
> 
> 
> 
> cleanEx()
> nameEx("rem.stat.pref.attach")
> ### * rem.stat.pref.attach
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rem.stat.pref.attach
> ### Title: Compute the Preferential Attachment Statistic for Relational
> ###   Event Sequences
> ### Aliases: rem.stat.pref.attach
> 
> ### ** Examples
> 
> 
> 
> # A Dummy One-Mode Event Dataset
> events <- data.table::data.table(time = 1:18,
+                                 eventID = 1:18,
+                                 sender = c("A", "B", "C",
+                                            "A", "D", "E",
+                                            "F", "B", "A",
+                                            "F", "D", "B",
+                                            "G", "B", "D",
+                                            "H", "A", "D"),
+                                 target = c("B", "C", "D",
+                                            "E", "A", "F",
+                                            "D", "A", "C",
+                                            "G", "B", "C",
+                                            "H", "J", "A",
+                                            "F", "C", "B"))
> 
> # Creating the Post-Processing Event Dataset with Null Events
> eventSet <- rem.riskset.om(data = events,
+                           time = events$time,
+                           eventID = events$eventID,
+                           sender = events$sender,
+                           receiver = events$target,
+                           p_samplingobserved = 1.00,
+                          n_controls = 6,
+                          seed = 9999)
> 
> # Compute Preferential Attachment Statistic without Sliding Windows Framework and
> # No Temporal Dependency
> eventSet$pref <- rem.stat.pref.attach(observed_time = events$time,
+                                      observed_receiver = events$target,
+                                      observed_sender = events$sender,
+                                      processed_time = eventSet$time,
+                                      processed_receiver = eventSet$receiver,
+                                      processed_sender = eventSet$sender,
+                                     dependency = FALSE)
> 
> # Compute Preferential Attachment Statistic with Sliding Windows Framework and
> # No Temporal Dependency
> eventSet$prefSW <- rem.stat.pref.attach(observed_time = events$time,
+                                        observed_receiver = events$target,
+                                        observed_sender = events$sender,
+                                        processed_time = eventSet$time,
+                                        processed_receiver = eventSet$receiver,
+                                        processed_sender = eventSet$sender,
+                                        dependency = FALSE,
+                                        sliding_windows = TRUE,
+                                        processed_seqIDs = eventSet$sequenceID)
> 
> #The results with and without the sliding windows are the same (see correlation below).
> #Using the sliding windows method is recommended when the data are 'big' so
> #that memory allotment is more efficient.
> cor(eventSet$pref,eventSet$prefSW) #the correlation of the values
[1] 1
> 
> 
> # Compute Preferential Attachment Statistic without Sliding Windows Framework and
> # Temporal Dependency
> eventSet$prefdep <- rem.stat.pref.attach(observed_time = events$time,
+                                         observed_receiver = events$target,
+                                         observed_sender = events$sender,
+                                         processed_time = eventSet$time,
+                                         processed_receiver = eventSet$receiver,
+                                         processed_sender = eventSet$sender,
+                                         dependency = TRUE,
+                                         relationalTimeSpan = 10)
> 
> # Compute Preferential Attachment Statistic with Sliding Windows Framework and
> # Temporal Dependency
> eventSet$pref1dep <- rem.stat.pref.attach(observed_time = events$time,
+                                          observed_receiver = events$target,
+                                          observed_sender = events$sender,
+                                          processed_time = eventSet$time,
+                                          processed_receiver = eventSet$receiver,
+                                          processed_sender = eventSet$sender,
+                                          dependency = TRUE,
+                                          relationalTimeSpan = 10,
+                                         sliding_windows = TRUE,
+                                          processed_seqIDs = eventSet$sequenceID)
> 
> #The results with and without the sliding windows are the same (see correlation below).
> #Using the sliding windows method is recommended when the data are 'big' so
> #that memory allotment is more efficient.
> cor(eventSet$prefdep,eventSet$pref1dep) #the correlation of the values
[1] 1
> 
> 
> 
> 
> cleanEx()
> nameEx("rem.stat.presistence")
> ### * rem.stat.presistence
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rem.stat.presistence
> ### Title: Compute Persistence Statistic for Relational Event Sequences
> ### Aliases: rem.stat.presistence rem.stat.persistence
> 
> ### ** Examples
> 
> 
> 
> # A Dummy One-Mode Event Dataset
> events <- data.table::data.table(time = 1:18,
+                                 eventID = 1:18,
+                                 sender = c("A", "B", "C",
+                                            "A", "D", "E",
+                                            "F", "B", "A",
+                                            "F", "D", "B",
+                                            "G", "B", "D",
+                                            "H", "A", "D"),
+                                 target = c("B", "C", "D",
+                                            "E", "A", "F",
+                                            "D", "A", "C",
+                                            "G", "B", "C",
+                                            "H", "J", "A",
+                                            "F", "C", "B"))
> 
> # Creating the Post-Processing Event Dataset with Null Events
> eventSet <- rem.riskset.om(data = events,
+                           time = events$time,
+                           eventID = events$eventID,
+                           sender = events$sender,
+                           receiver = events$target,
+                           p_samplingobserved = 1.00,
+                           n_controls = 6,
+                           seed = 9999)
> 
> #Compute Persistence with respect to the sender's past relational history without
> #the sliding windows framework and no temporal dependency
> eventSet$persist <- rem.stat.persistence(observed_time = events$time,
+                                         observed_receiver = events$target,
+                                         observed_sender = events$sender,
+                                         processed_time = eventSet$time,
+                                         processed_receiver = eventSet$receiver,
+                                         processed_sender = eventSet$sender,
+                                         sender = TRUE,
+                                         nopastEvents = 0)
> 
> #Compute Persistence with respect to the sender's past relational history with
> #the sliding windows framework and no temporal dependency
> eventSet$persistSW <- rem.stat.persistence(observed_time = events$time,
+                                         observed_receiver = events$target,
+                                         observed_sender = events$sender,
+                                         processed_time = eventSet$time,
+                                         processed_receiver = eventSet$receiver,
+                                         processed_sender = eventSet$sender,
+                                         sender = TRUE,
+                                         sliding_windows = TRUE,
+                                         processed_seqIDs = eventSet$sequenceID,
+                                         nopastEvents = 0)
Setting up data structure for the sliding windows framework.......
> 
> #The results with and without the sliding windows are the same (see correlation below).
> #Using the sliding windows method is recommended when the data are 'big' so
> #that memory allotment is more efficient.
> cor(eventSet$persist,eventSet$persistSW)
[1] 1
> 
> 
> #Compute Persistence with respect to the sender's past relational history without
> #the sliding windows framework and temporal dependency
> eventSet$persistDep <- rem.stat.persistence(observed_time = events$time,
+                                         observed_receiver = events$target,
+                                         observed_sender = events$sender,
+                                         processed_time = eventSet$time,
+                                         processed_receiver = eventSet$receiver,
+                                         processed_sender = eventSet$sender,
+                                         sender = TRUE,
+                                         dependency = TRUE,
+                                         relationalTimeSpan = 5, #the past 5 events
+                                         nopastEvents = 0)
> 
> #Compute Persistence with respect to the receiver's past relational history without
> #the sliding windows framework and no temporal dependency
> eventSet$persistT <- rem.stat.persistence(observed_time = events$time,
+                                         observed_receiver = events$target,
+                                         observed_sender = events$sender,
+                                         processed_time = eventSet$time,
+                                         processed_receiver = eventSet$receiver,
+                                         processed_sender = eventSet$sender,
+                                         sender = FALSE,
+                                         nopastEvents = 0)
> 
> #Compute Persistence with respect to the receiver's past relational history with
> #the sliding windows framework and no temporal dependency
> eventSet$persistSWT <- rem.stat.persistence(observed_time = events$time,
+                                         observed_receiver = events$target,
+                                         observed_sender = events$sender,
+                                         processed_time = eventSet$time,
+                                         processed_receiver = eventSet$receiver,
+                                         processed_sender = eventSet$sender,
+                                         sender = FALSE,
+                                         sliding_windows = TRUE,
+                                         processed_seqIDs = eventSet$sequenceID,
+                                         nopastEvents = 0)
Setting up data structure for the sliding windows framework.......
> 
> #The results with and without the sliding windows are the same (see correlation below).
> #Using the sliding windows method is recommended when the data are 'big' so
> #that memory allotment is more efficient.
> cor(eventSet$persistT,eventSet$persistSWT)
[1] 1
> 
> 
> #Compute Persistence with respect to the receiver's past relational history without
> #the sliding windows framework and temporal dependency
> eventSet$persistDepT <- rem.stat.persistence(observed_time = events$time,
+                                         observed_receiver = events$target,
+                                         observed_sender = events$sender,
+                                         processed_time = eventSet$time,
+                                         processed_receiver = eventSet$receiver,
+                                         processed_sender = eventSet$sender,
+                                         sender = FALSE,
+                                         dependency = TRUE,
+                                         relationalTimeSpan = 5, #the past 5 events
+                                         nopastEvents = 0)
> 
> 
> 
> 
> cleanEx()
> nameEx("rem.stat.recency")
> ### * rem.stat.recency
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rem.stat.recency
> ### Title: Compute the Recency Statistic for Relational Event Sequences
> ### Aliases: rem.stat.recency
> 
> ### ** Examples
> 
> 
> 
> # A Dummy One-Mode Event Dataset
> events <- data.table::data.table(time = 1:18,
+                                 eventID = 1:18,
+                                 sender = c("A", "B", "C",
+                                            "A", "D", "E",
+                                            "F", "B", "A",
+                                            "F", "D", "B",
+                                            "G", "B", "D",
+                                            "H", "A", "D"),
+                                 target = c("B", "C", "D",
+                                            "E", "A", "F",
+                                            "D", "A", "C",
+                                            "G", "B", "C",
+                                            "H", "J", "A",
+                                            "F", "C", "B"))
> 
> # Creating the Post-Processing Event Dataset with Null Events
> eventSet <- rem.riskset.om(data = events,
+                           time = events$time,
+                           eventID = events$eventID,
+                           sender = events$sender,
+                           receiver = events$target,
+                           p_samplingobserved = 1.00,
+                          n_controls = 6,
+                          seed = 9999)
> 
> # Compute Recency Statistic without Sliding Windows Framework and
> # No Temporal Dependency
> eventSet$recency_rawdiff <- rem.stat.recency(
+  observed_time = events$time, # variable (column) name that contains the time variable
+  observed_receiver = events$target, # variable (column) name that contains the receiver variable
+  observed_sender = events$sender,
+  processed_time = eventSet$time,
+  processed_receiver = eventSet$receiver,
+  processed_sender = eventSet$sender,
+  type = "raw.diff",
+  dependency = FALSE,
+  i_neighborhood = TRUE,
+  nopastEvents = 0)
> 
> # Compute Recency Statistic without Sliding Windows Framework and
> # No Temporal Dependency
> eventSet$recency_inv <- rem.stat.recency(
+  observed_time = events$time, # variable (column) name that contains the time variable
+  observed_receiver = events$target, # variable (column) name that contains the receiver variable
+  observed_sender = events$sender,
+  processed_time = eventSet$time,
+  processed_receiver = eventSet$receiver,
+  processed_sender = eventSet$sender,
+  type = "inv.diff.plus1",
+  dependency = FALSE,
+  i_neighborhood = TRUE,
+  nopastEvents = 0)
> 
> 
> # Compute Recency Statistic without Sliding Windows Framework and
> # No Temporal Dependency
> eventSet$recency_rank <- rem.stat.recency(
+  observed_time = events$time,
+  observed_receiver = events$target,
+  observed_sender = events$sender,
+  processed_time = eventSet$time,
+  processed_receiver = eventSet$receiver,
+  processed_sender = eventSet$sender,
+  type = "rank.ordered.count",
+  dependency = FALSE,
+  i_neighborhood = TRUE,
+  nopastEvents = 0)
> 
> # Compute Recency Statistic with Sliding Windows Framework and No Temporal Dependency
> eventSet$recency_rawdiffSW <- rem.stat.recency(
+  observed_time = events$time,
+  observed_receiver = events$target,
+  observed_sender = events$sender,
+  processed_time = eventSet$time,
+  processed_receiver = eventSet$receiver,
+  processed_sender = eventSet$sender,
+  type = "raw.diff",
+  dependency = FALSE,
+  i_neighborhood = TRUE,
+  sliding_windows = TRUE,
+  processed_seqIDs = eventSet$sequenceID,
+  nopastEvents = 0)
> 
> 
> # Compute Recency Statistic with Sliding Windows Framework and No Temporal Dependency
> eventSet$recency_invSW <- rem.stat.recency(
+  observed_time = events$time,
+  observed_receiver = events$target,
+  observed_sender = events$sender,
+  processed_time = eventSet$time,
+  processed_receiver = eventSet$receiver,
+  processed_sender = eventSet$sender,
+  type = "inv.diff.plus1",
+  dependency = FALSE,
+  i_neighborhood = TRUE,
+  sliding_windows = TRUE,
+  processed_seqIDs = eventSet$sequenceID,
+  nopastEvents = 0)
> 
> 
> # Compute Recency Statistic with Sliding Windows Framework and No Temporal Dependency
> eventSet$recency_rankSW <- rem.stat.recency(
+  observed_time = events$time,
+  observed_receiver = events$target,
+  observed_sender = events$sender,
+  processed_time = eventSet$time,
+  processed_receiver = eventSet$receiver,
+  processed_sender = eventSet$sender,
+  type = "rank.ordered.count",
+  dependency = FALSE,
+  i_neighborhood = TRUE,
+  sliding_windows = TRUE,
+  processed_seqIDs = eventSet$sequenceID,
+  nopastEvents = 0)
> 
> 
> 
> 
> cleanEx()
> nameEx("rem.stat.recip")
> ### * rem.stat.recip
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rem.stat.recip
> ### Title: Compute Reciprocity Statistic for Relational Event Sequences
> ### Aliases: rem.stat.recip
> 
> ### ** Examples
> 
> events <- data.table::data.table(time = 1:18,
+                                 eventID = 1:18,
+                                 sender = c("A", "B", "C",
+                                            "A", "D", "E",
+                                            "F", "B", "A",
+                                            "F", "D", "B",
+                                            "G", "B", "D",
+                                           "H", "A", "D"),
+                                target = c("B", "C", "D",
+                                           "E", "A", "F",
+                                           "D", "A", "C",
+                                           "G", "B", "C",
+                                           "H", "J", "A",
+                                           "F", "C", "B"))
> 
> eventSet <- rem.riskset.om(data = events,
+                       time = events$time,
+                       eventID = events$eventID,
+                       sender = events$sender,
+                       receiver = events$target,
+                       p_samplingobserved = 1.00,
+                       n_controls = 1,
+                       seed = 9999)
> 
> # Computing Reciprocity Statistics without the sliding windows framework
> eventSet$recip <- rem.stat.recip(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_sender = events$sender, # variable (column) name that contains the sender variable
+    observed_receiver = events$target, # variable (column) name that contains the receiver variable
+    processed_time = eventSet$time,
+    processed_sender = eventSet$sender,
+    processed_receiver = eventSet$receiver,
+    halflife = 2, #halflife parameter
+    dyadic_weight = 0,
+    Lerneretal_2013 = FALSE)
> 
> # Computing Reciprocity Statistics with the sliding windows framework
> eventSet$recipSW <- rem.stat.recip(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_sender = events$sender, # variable (column) name that contains the sender variable
+    observed_receiver = events$target, # variable (column) name that contains the receiver variable
+    processed_time = eventSet$time,
+    processed_sender = eventSet$sender,
+    processed_receiver = eventSet$receiver,
+    halflife = 2, #halflife parameter
+    processed_seqIDs = eventSet$sequenceID,
+    dyadic_weight = 0,
+    sliding_window = TRUE,
+    Lerneretal_2013 = FALSE)
> 
> #The results with and without the sliding windows are the same (see correlation below).
> #Using the sliding windows method is recommended when the data are 'big' so
> #that memory allotment is more efficient.
> cor(eventSet$recipSW , eventSet$recip)
[1] 1
> 
> # Computing Reciprocity Statistics with the counts of events being returned
> eventSet$recipC <- rem.stat.recip(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_sender = events$sender, # variable (column) name that contains the sender variable
+    observed_receiver = events$target, # variable (column) name that contains the receiver variable
+    processed_time = eventSet$time,
+    processed_sender = eventSet$sender,
+    processed_receiver = eventSet$receiver,
+    halflife = 2, #halflife parameter
+    dyadic_weight = 0,
+    sliding_window = FALSE,
+    counts = TRUE,
+    Lerneretal_2013 = FALSE)
> 
> cbind(eventSet$recip,
+      eventSet$recipSW,
+      eventSet$recipC)
            [,1]       [,2] [,3]
 [1,] 0.00000000 0.00000000    0
 [2,] 0.00000000 0.00000000    0
 [3,] 0.70710678 0.70710678    1
 [4,] 0.00000000 0.00000000    0
 [5,] 0.50000000 0.50000000    1
 [6,] 0.00000000 0.00000000    0
 [7,] 0.00000000 0.00000000    0
 [8,] 0.00000000 0.00000000    0
 [9,] 0.00000000 0.00000000    0
[10,] 0.00000000 0.00000000    0
[11,] 0.00000000 0.00000000    0
[12,] 0.00000000 0.00000000    0
[13,] 0.00000000 0.00000000    0
[14,] 0.08838835 0.08838835    1
[15,] 0.00000000 0.00000000    0
[16,] 0.00000000 0.00000000    0
[17,] 0.25000000 0.25000000    1
[18,] 0.00000000 0.00000000    0
[19,] 0.12500000 0.12500000    1
[20,] 0.00000000 0.00000000    0
[21,] 0.00000000 0.00000000    0
[22,] 0.00000000 0.00000000    0
[23,] 0.00000000 0.00000000    0
[24,] 0.00000000 0.00000000    0
[25,] 0.00000000 0.00000000    0
[26,] 0.00000000 0.00000000    0
[27,] 0.00000000 0.00000000    0
[28,] 0.00000000 0.00000000    0
[29,] 0.06250000 0.06250000    1
[30,] 0.00000000 0.00000000    0
[31,] 0.00000000 0.00000000    0
[32,] 0.00000000 0.00000000    0
[33,] 0.00000000 0.00000000    0
[34,] 0.00000000 0.00000000    0
[35,] 0.00000000 0.00000000    0
> 
> 
> 
> cleanEx()
> nameEx("rem.stat.repetition")
> ### * rem.stat.repetition
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rem.stat.repetition
> ### Title: Compute Repetition Statistic for Relational Event Sequences
> ### Aliases: rem.stat.repetition
> 
> ### ** Examples
> 
> data("WikiEvent2018.first100k")
> WikiEvent2018 <- WikiEvent2018.first100k[1:10000,] #the first ten thousand events
> WikiEvent2018$time <- as.numeric(WikiEvent2018$time) #making the variable numeric
> ### Creating the EventSet By Employing Case-Control Sampling With M = 5 and
> ### Sampling from the Observed Event Sequence with P = 0.01
> EventSet <- rem.riskset.tm(
+  data = WikiEvent2018, # The Event Dataset
+  time = WikiEvent2018$time, # The Time Variable
+  eventID = WikiEvent2018$eventID, # The Event Sequence Variable
+  sender = WikiEvent2018$user, # The Sender Variable
+  receiver = WikiEvent2018$article, # The Receiver Variable
+  p_samplingobserved = 0.01, # The Probability of Selection
+  n_controls = 5, # The Number of Controls to Sample from the Full Risk Set
+  seed = 9999) # The Seed for Replication
> #### Estimating Repetition Scores Without the Sliding Windows Framework
> EventSet$rep <- rem.stat.repetition(
+    observed_time = WikiEvent2018$time,
+    observed_sender = WikiEvent2018$user,
+    observed_receiver = WikiEvent2018$article,
+    processed_time = EventSet$time,
+    processed_sender = EventSet$sender,
+    processed_receiver = EventSet$receiver,
+    halflife = 2.592e+09, #halflife parameter
+    dyadic_weight = 0,
+    Lerneretal_2013 = FALSE)
> 
> EventSet$sw_rep <- rem.stat.repetition(
+    observed_time = WikiEvent2018$time,
+    observed_sender = WikiEvent2018$user,
+    observed_receiver = WikiEvent2018$article,
+    processed_time = EventSet$time,
+    processed_sender = EventSet$sender,
+    processed_receiver = EventSet$receiver,
+    processed_seqIDs = EventSet$sequenceID,
+    halflife = 2.592e+09, #halflife parameter
+    dyadic_weight = 0,
+    sliding_window = TRUE,
+    Lerneretal_2013 = FALSE)
> 
> #The results with and without the sliding windows are the same (see correlation below).
> #Using the sliding windows method is recommended when the data are 'big' so
> #that memory allotment is more efficient.
> cor(EventSet$sw_rep, EventSet$rep)
[1] 1
> 
> #### Estimating Repetition Scores with the Counts of Events Returned
> EventSet$repC <- rem.stat.repetition(
+    observed_time = WikiEvent2018$time,
+    observed_sender = WikiEvent2018$user,
+    observed_receiver = WikiEvent2018$article,
+    processed_time = EventSet$time,
+    processed_sender = EventSet$sender,
+    processed_receiver = EventSet$receiver,
+    halflife = 2.592e+09, #halflife parameter
+    dyadic_weight = 0,
+    Lerneretal_2013 = FALSE,
+    counts = TRUE)
> 
> cbind(EventSet$rep,
+      EventSet$sw_rep,
+      EventSet$repC)
            [,1]      [,2] [,3]
  [1,] 0.0000000 0.0000000    0
  [2,] 0.0000000 0.0000000    0
  [3,] 0.0000000 0.0000000    0
  [4,] 0.0000000 0.0000000    0
  [5,] 0.0000000 0.0000000    0
  [6,] 0.0000000 0.0000000    0
  [7,] 0.0000000 0.0000000    0
  [8,] 0.0000000 0.0000000    0
  [9,] 0.0000000 0.0000000    0
 [10,] 0.0000000 0.0000000    0
 [11,] 0.0000000 0.0000000    0
 [12,] 0.0000000 0.0000000    0
 [13,] 0.0000000 0.0000000    0
 [14,] 0.0000000 0.0000000    0
 [15,] 0.0000000 0.0000000    0
 [16,] 0.0000000 0.0000000    0
 [17,] 0.0000000 0.0000000    0
 [18,] 0.0000000 0.0000000    0
 [19,] 0.0000000 0.0000000    0
 [20,] 0.0000000 0.0000000    0
 [21,] 0.0000000 0.0000000    0
 [22,] 0.0000000 0.0000000    0
 [23,] 0.0000000 0.0000000    0
 [24,] 0.0000000 0.0000000    0
 [25,] 0.0000000 0.0000000    0
 [26,] 0.0000000 0.0000000    0
 [27,] 0.0000000 0.0000000    0
 [28,] 0.0000000 0.0000000    0
 [29,] 0.0000000 0.0000000    0
 [30,] 0.0000000 0.0000000    0
 [31,] 0.0000000 0.0000000    0
 [32,] 0.0000000 0.0000000    0
 [33,] 0.0000000 0.0000000    0
 [34,] 0.0000000 0.0000000    0
 [35,] 0.0000000 0.0000000    0
 [36,] 0.0000000 0.0000000    0
 [37,] 0.0000000 0.0000000    0
 [38,] 0.0000000 0.0000000    0
 [39,] 0.0000000 0.0000000    0
 [40,] 0.0000000 0.0000000    0
 [41,] 0.0000000 0.0000000    0
 [42,] 0.0000000 0.0000000    0
 [43,] 0.0000000 0.0000000    0
 [44,] 0.0000000 0.0000000    0
 [45,] 0.0000000 0.0000000    0
 [46,] 0.0000000 0.0000000    0
 [47,] 0.0000000 0.0000000    0
 [48,] 0.0000000 0.0000000    0
 [49,] 0.0000000 0.0000000    0
 [50,] 0.0000000 0.0000000    0
 [51,] 0.0000000 0.0000000    0
 [52,] 0.0000000 0.0000000    0
 [53,] 0.0000000 0.0000000    0
 [54,] 0.0000000 0.0000000    0
 [55,] 0.9999658 0.9999658    1
 [56,] 0.0000000 0.0000000    0
 [57,] 0.0000000 0.0000000    0
 [58,] 0.0000000 0.0000000    0
 [59,] 0.0000000 0.0000000    0
 [60,] 0.0000000 0.0000000    0
 [61,] 0.0000000 0.0000000    0
 [62,] 0.0000000 0.0000000    0
 [63,] 0.0000000 0.0000000    0
 [64,] 0.0000000 0.0000000    0
 [65,] 0.0000000 0.0000000    0
 [66,] 0.0000000 0.0000000    0
 [67,] 0.0000000 0.0000000    0
 [68,] 0.0000000 0.0000000    0
 [69,] 0.0000000 0.0000000    0
 [70,] 0.0000000 0.0000000    0
 [71,] 0.0000000 0.0000000    0
 [72,] 0.0000000 0.0000000    0
 [73,] 0.0000000 0.0000000    0
 [74,] 0.0000000 0.0000000    0
 [75,] 0.0000000 0.0000000    0
 [76,] 0.0000000 0.0000000    0
 [77,] 0.0000000 0.0000000    0
 [78,] 0.0000000 0.0000000    0
 [79,] 0.0000000 0.0000000    0
 [80,] 0.0000000 0.0000000    0
 [81,] 0.0000000 0.0000000    0
 [82,] 0.0000000 0.0000000    0
 [83,] 0.0000000 0.0000000    0
 [84,] 0.0000000 0.0000000    0
 [85,] 0.0000000 0.0000000    0
 [86,] 0.0000000 0.0000000    0
 [87,] 0.0000000 0.0000000    0
 [88,] 0.0000000 0.0000000    0
 [89,] 0.0000000 0.0000000    0
 [90,] 0.0000000 0.0000000    0
 [91,] 0.0000000 0.0000000    0
 [92,] 0.0000000 0.0000000    0
 [93,] 0.0000000 0.0000000    0
 [94,] 0.0000000 0.0000000    0
 [95,] 0.0000000 0.0000000    0
 [96,] 0.0000000 0.0000000    0
 [97,] 0.0000000 0.0000000    0
 [98,] 0.0000000 0.0000000    0
 [99,] 0.0000000 0.0000000    0
[100,] 0.0000000 0.0000000    0
[101,] 0.0000000 0.0000000    0
[102,] 0.0000000 0.0000000    0
[103,] 0.0000000 0.0000000    0
[104,] 0.0000000 0.0000000    0
[105,] 0.0000000 0.0000000    0
[106,] 0.0000000 0.0000000    0
[107,] 0.0000000 0.0000000    0
[108,] 0.0000000 0.0000000    0
[109,] 0.0000000 0.0000000    0
[110,] 0.0000000 0.0000000    0
[111,] 0.0000000 0.0000000    0
[112,] 0.0000000 0.0000000    0
[113,] 0.0000000 0.0000000    0
[114,] 0.0000000 0.0000000    0
[115,] 0.0000000 0.0000000    0
[116,] 0.0000000 0.0000000    0
[117,] 0.0000000 0.0000000    0
[118,] 0.0000000 0.0000000    0
[119,] 0.0000000 0.0000000    0
[120,] 0.0000000 0.0000000    0
[121,] 0.0000000 0.0000000    0
[122,] 0.0000000 0.0000000    0
[123,] 0.0000000 0.0000000    0
[124,] 0.0000000 0.0000000    0
[125,] 0.0000000 0.0000000    0
[126,] 0.0000000 0.0000000    0
[127,] 0.0000000 0.0000000    0
[128,] 0.0000000 0.0000000    0
[129,] 0.0000000 0.0000000    0
[130,] 0.0000000 0.0000000    0
[131,] 0.0000000 0.0000000    0
[132,] 0.0000000 0.0000000    0
[133,] 0.0000000 0.0000000    0
[134,] 0.0000000 0.0000000    0
[135,] 0.0000000 0.0000000    0
[136,] 0.0000000 0.0000000    0
[137,] 0.0000000 0.0000000    0
[138,] 0.0000000 0.0000000    0
[139,] 0.9999904 0.9999904    1
[140,] 0.0000000 0.0000000    0
[141,] 0.0000000 0.0000000    0
[142,] 0.0000000 0.0000000    0
[143,] 0.0000000 0.0000000    0
[144,] 0.0000000 0.0000000    0
[145,] 0.0000000 0.0000000    0
[146,] 0.0000000 0.0000000    0
[147,] 0.0000000 0.0000000    0
[148,] 0.0000000 0.0000000    0
[149,] 0.0000000 0.0000000    0
[150,] 0.0000000 0.0000000    0
[151,] 0.0000000 0.0000000    0
[152,] 0.0000000 0.0000000    0
[153,] 0.0000000 0.0000000    0
[154,] 0.0000000 0.0000000    0
[155,] 0.0000000 0.0000000    0
[156,] 0.0000000 0.0000000    0
[157,] 0.0000000 0.0000000    0
[158,] 0.0000000 0.0000000    0
[159,] 0.0000000 0.0000000    0
[160,] 0.0000000 0.0000000    0
[161,] 0.0000000 0.0000000    0
[162,] 0.0000000 0.0000000    0
[163,] 0.0000000 0.0000000    0
[164,] 0.0000000 0.0000000    0
[165,] 0.0000000 0.0000000    0
[166,] 0.0000000 0.0000000    0
[167,] 0.0000000 0.0000000    0
[168,] 0.0000000 0.0000000    0
[169,] 0.0000000 0.0000000    0
[170,] 0.0000000 0.0000000    0
[171,] 0.0000000 0.0000000    0
[172,] 0.0000000 0.0000000    0
[173,] 0.0000000 0.0000000    0
[174,] 0.0000000 0.0000000    0
[175,] 0.0000000 0.0000000    0
[176,] 0.0000000 0.0000000    0
[177,] 0.0000000 0.0000000    0
[178,] 0.0000000 0.0000000    0
[179,] 0.0000000 0.0000000    0
[180,] 0.0000000 0.0000000    0
[181,] 0.0000000 0.0000000    0
[182,] 0.0000000 0.0000000    0
[183,] 0.0000000 0.0000000    0
[184,] 0.0000000 0.0000000    0
[185,] 0.0000000 0.0000000    0
[186,] 0.0000000 0.0000000    0
[187,] 0.0000000 0.0000000    0
[188,] 0.0000000 0.0000000    0
[189,] 0.0000000 0.0000000    0
[190,] 0.0000000 0.0000000    0
[191,] 0.0000000 0.0000000    0
[192,] 0.0000000 0.0000000    0
[193,] 0.0000000 0.0000000    0
[194,] 0.0000000 0.0000000    0
[195,] 0.0000000 0.0000000    0
[196,] 0.0000000 0.0000000    0
[197,] 0.0000000 0.0000000    0
[198,] 0.0000000 0.0000000    0
[199,] 0.0000000 0.0000000    0
[200,] 0.0000000 0.0000000    0
[201,] 0.0000000 0.0000000    0
[202,] 0.0000000 0.0000000    0
[203,] 0.0000000 0.0000000    0
[204,] 0.0000000 0.0000000    0
[205,] 0.0000000 0.0000000    0
[206,] 0.0000000 0.0000000    0
[207,] 0.0000000 0.0000000    0
[208,] 0.0000000 0.0000000    0
[209,] 0.0000000 0.0000000    0
[210,] 0.0000000 0.0000000    0
[211,] 0.0000000 0.0000000    0
[212,] 0.0000000 0.0000000    0
[213,] 0.0000000 0.0000000    0
[214,] 0.0000000 0.0000000    0
[215,] 0.0000000 0.0000000    0
[216,] 0.0000000 0.0000000    0
[217,] 0.0000000 0.0000000    0
[218,] 0.0000000 0.0000000    0
[219,] 0.0000000 0.0000000    0
[220,] 0.0000000 0.0000000    0
[221,] 0.0000000 0.0000000    0
[222,] 0.0000000 0.0000000    0
[223,] 0.0000000 0.0000000    0
[224,] 0.0000000 0.0000000    0
[225,] 0.0000000 0.0000000    0
[226,] 0.0000000 0.0000000    0
[227,] 0.0000000 0.0000000    0
[228,] 0.0000000 0.0000000    0
[229,] 0.0000000 0.0000000    0
[230,] 0.0000000 0.0000000    0
[231,] 0.0000000 0.0000000    0
[232,] 0.0000000 0.0000000    0
[233,] 0.0000000 0.0000000    0
[234,] 0.0000000 0.0000000    0
[235,] 0.0000000 0.0000000    0
[236,] 0.0000000 0.0000000    0
[237,] 0.0000000 0.0000000    0
[238,] 0.0000000 0.0000000    0
[239,] 0.0000000 0.0000000    0
[240,] 0.0000000 0.0000000    0
[241,] 0.0000000 0.0000000    0
[242,] 0.0000000 0.0000000    0
[243,] 0.0000000 0.0000000    0
[244,] 0.0000000 0.0000000    0
[245,] 0.0000000 0.0000000    0
[246,] 0.0000000 0.0000000    0
[247,] 0.0000000 0.0000000    0
[248,] 0.0000000 0.0000000    0
[249,] 0.0000000 0.0000000    0
[250,] 0.0000000 0.0000000    0
[251,] 0.0000000 0.0000000    0
[252,] 0.0000000 0.0000000    0
[253,] 0.0000000 0.0000000    0
[254,] 0.0000000 0.0000000    0
[255,] 0.0000000 0.0000000    0
[256,] 0.0000000 0.0000000    0
[257,] 0.0000000 0.0000000    0
[258,] 0.0000000 0.0000000    0
[259,] 0.9970123 0.9970123    1
[260,] 0.0000000 0.0000000    0
[261,] 0.0000000 0.0000000    0
[262,] 0.0000000 0.0000000    0
[263,] 0.0000000 0.0000000    0
[264,] 0.0000000 0.0000000    0
[265,] 0.0000000 0.0000000    0
[266,] 0.0000000 0.0000000    0
[267,] 0.0000000 0.0000000    0
[268,] 0.0000000 0.0000000    0
[269,] 0.0000000 0.0000000    0
[270,] 0.0000000 0.0000000    0
[271,] 0.9994303 0.9994303    1
[272,] 0.0000000 0.0000000    0
[273,] 0.0000000 0.0000000    0
[274,] 0.0000000 0.0000000    0
[275,] 0.0000000 0.0000000    0
[276,] 0.0000000 0.0000000    0
[277,] 0.0000000 0.0000000    0
[278,] 0.0000000 0.0000000    0
[279,] 0.0000000 0.0000000    0
[280,] 0.0000000 0.0000000    0
[281,] 0.0000000 0.0000000    0
[282,] 0.0000000 0.0000000    0
[283,] 0.9823392 0.9823392    1
[284,] 0.0000000 0.0000000    0
[285,] 0.0000000 0.0000000    0
[286,] 0.0000000 0.0000000    0
[287,] 0.0000000 0.0000000    0
[288,] 0.0000000 0.0000000    0
[289,] 0.0000000 0.0000000    0
[290,] 0.0000000 0.0000000    0
[291,] 0.0000000 0.0000000    0
[292,] 0.0000000 0.0000000    0
[293,] 0.0000000 0.0000000    0
[294,] 0.0000000 0.0000000    0
[295,] 0.0000000 0.0000000    0
[296,] 0.0000000 0.0000000    0
[297,] 0.0000000 0.0000000    0
[298,] 0.0000000 0.0000000    0
[299,] 0.0000000 0.0000000    0
[300,] 0.0000000 0.0000000    0
[301,] 0.0000000 0.0000000    0
[302,] 0.0000000 0.0000000    0
[303,] 0.0000000 0.0000000    0
[304,] 0.0000000 0.0000000    0
[305,] 0.0000000 0.0000000    0
[306,] 0.0000000 0.0000000    0
[307,] 0.9735462 0.9735462    1
[308,] 0.0000000 0.0000000    0
[309,] 0.0000000 0.0000000    0
[310,] 0.0000000 0.0000000    0
[311,] 0.0000000 0.0000000    0
[312,] 0.0000000 0.0000000    0
[313,] 0.0000000 0.0000000    0
[314,] 0.0000000 0.0000000    0
[315,] 0.0000000 0.0000000    0
[316,] 0.0000000 0.0000000    0
[317,] 0.0000000 0.0000000    0
[318,] 0.0000000 0.0000000    0
[319,] 0.9999214 0.9999214    1
[320,] 0.0000000 0.0000000    0
[321,] 0.0000000 0.0000000    0
[322,] 0.0000000 0.0000000    0
[323,] 0.0000000 0.0000000    0
[324,] 0.0000000 0.0000000    0
[325,] 0.0000000 0.0000000    0
[326,] 0.0000000 0.0000000    0
[327,] 0.0000000 0.0000000    0
[328,] 0.0000000 0.0000000    0
[329,] 0.0000000 0.0000000    0
[330,] 0.0000000 0.0000000    0
[331,] 0.0000000 0.0000000    0
[332,] 0.0000000 0.0000000    0
[333,] 0.0000000 0.0000000    0
[334,] 0.0000000 0.0000000    0
[335,] 0.0000000 0.0000000    0
[336,] 0.0000000 0.0000000    0
[337,] 0.0000000 0.0000000    0
[338,] 0.0000000 0.0000000    0
[339,] 0.0000000 0.0000000    0
[340,] 0.0000000 0.0000000    0
[341,] 0.0000000 0.0000000    0
[342,] 0.0000000 0.0000000    0
[343,] 0.9991110 0.9991110    1
[344,] 0.0000000 0.0000000    0
[345,] 0.0000000 0.0000000    0
[346,] 0.0000000 0.0000000    0
[347,] 0.0000000 0.0000000    0
[348,] 0.0000000 0.0000000    0
[349,] 0.9999262 0.9999262    1
[350,] 0.0000000 0.0000000    0
[351,] 0.0000000 0.0000000    0
[352,] 0.0000000 0.0000000    0
[353,] 0.0000000 0.0000000    0
[354,] 0.0000000 0.0000000    0
[355,] 0.0000000 0.0000000    0
[356,] 0.0000000 0.0000000    0
[357,] 0.0000000 0.0000000    0
[358,] 0.0000000 0.0000000    0
[359,] 0.0000000 0.0000000    0
[360,] 0.0000000 0.0000000    0
[361,] 0.0000000 0.0000000    0
[362,] 0.0000000 0.0000000    0
[363,] 0.0000000 0.0000000    0
[364,] 0.0000000 0.0000000    0
[365,] 0.0000000 0.0000000    0
[366,] 0.0000000 0.0000000    0
[367,] 1.9772405 1.9772405    2
[368,] 0.0000000 0.0000000    0
[369,] 0.0000000 0.0000000    0
[370,] 0.0000000 0.0000000    0
[371,] 0.0000000 0.0000000    0
[372,] 0.0000000 0.0000000    0
[373,] 0.0000000 0.0000000    0
[374,] 0.0000000 0.0000000    0
[375,] 0.0000000 0.0000000    0
[376,] 0.0000000 0.0000000    0
[377,] 0.0000000 0.0000000    0
[378,] 0.0000000 0.0000000    0
[379,] 0.0000000 0.0000000    0
[380,] 0.0000000 0.0000000    0
[381,] 0.0000000 0.0000000    0
[382,] 0.0000000 0.0000000    0
[383,] 0.0000000 0.0000000    0
[384,] 0.0000000 0.0000000    0
[385,] 0.0000000 0.0000000    0
[386,] 0.0000000 0.0000000    0
[387,] 0.0000000 0.0000000    0
[388,] 0.0000000 0.0000000    0
[389,] 0.0000000 0.0000000    0
[390,] 0.0000000 0.0000000    0
[391,] 0.0000000 0.0000000    0
[392,] 0.0000000 0.0000000    0
[393,] 0.0000000 0.0000000    0
[394,] 0.0000000 0.0000000    0
[395,] 0.0000000 0.0000000    0
[396,] 0.0000000 0.0000000    0
[397,] 0.0000000 0.0000000    0
[398,] 0.0000000 0.0000000    0
[399,] 0.0000000 0.0000000    0
[400,] 0.0000000 0.0000000    0
[401,] 0.0000000 0.0000000    0
[402,] 0.0000000 0.0000000    0
[403,] 0.9999925 0.9999925    1
[404,] 0.0000000 0.0000000    0
[405,] 0.0000000 0.0000000    0
[406,] 0.0000000 0.0000000    0
[407,] 0.0000000 0.0000000    0
[408,] 0.0000000 0.0000000    0
[409,] 0.0000000 0.0000000    0
[410,] 0.0000000 0.0000000    0
[411,] 0.0000000 0.0000000    0
[412,] 0.0000000 0.0000000    0
[413,] 0.0000000 0.0000000    0
[414,] 0.0000000 0.0000000    0
[415,] 0.0000000 0.0000000    0
[416,] 0.0000000 0.0000000    0
[417,] 0.0000000 0.0000000    0
[418,] 0.0000000 0.0000000    0
[419,] 0.0000000 0.0000000    0
[420,] 0.0000000 0.0000000    0
[421,] 0.9999401 0.9999401    1
[422,] 0.0000000 0.0000000    0
[423,] 0.0000000 0.0000000    0
[424,] 0.0000000 0.0000000    0
[425,] 0.0000000 0.0000000    0
[426,] 0.0000000 0.0000000    0
[427,] 0.0000000 0.0000000    0
[428,] 0.0000000 0.0000000    0
[429,] 0.0000000 0.0000000    0
[430,] 0.0000000 0.0000000    0
[431,] 0.0000000 0.0000000    0
[432,] 0.0000000 0.0000000    0
[433,] 0.0000000 0.0000000    0
[434,] 0.0000000 0.0000000    0
[435,] 0.0000000 0.0000000    0
[436,] 0.0000000 0.0000000    0
[437,] 0.0000000 0.0000000    0
[438,] 0.0000000 0.0000000    0
[439,] 1.9989663 1.9989663    2
[440,] 0.0000000 0.0000000    0
[441,] 0.0000000 0.0000000    0
[442,] 0.0000000 0.0000000    0
[443,] 0.0000000 0.0000000    0
[444,] 0.0000000 0.0000000    0
[445,] 0.0000000 0.0000000    0
[446,] 0.0000000 0.0000000    0
[447,] 0.0000000 0.0000000    0
[448,] 0.0000000 0.0000000    0
[449,] 0.0000000 0.0000000    0
[450,] 0.0000000 0.0000000    0
[451,] 0.9999856 0.9999856    1
[452,] 0.0000000 0.0000000    0
[453,] 0.0000000 0.0000000    0
[454,] 0.0000000 0.0000000    0
[455,] 0.0000000 0.0000000    0
[456,] 0.0000000 0.0000000    0
[457,] 0.0000000 0.0000000    0
[458,] 0.0000000 0.0000000    0
[459,] 0.9362995 0.9362995    1
[460,] 0.0000000 0.0000000    0
[461,] 0.0000000 0.0000000    0
[462,] 0.0000000 0.0000000    0
[463,] 0.0000000 0.0000000    0
[464,] 0.0000000 0.0000000    0
[465,] 0.0000000 0.0000000    0
[466,] 0.0000000 0.0000000    0
[467,] 0.0000000 0.0000000    0
[468,] 0.0000000 0.0000000    0
[469,] 0.0000000 0.0000000    0
[470,] 0.0000000 0.0000000    0
[471,] 0.0000000 0.0000000    0
[472,] 0.0000000 0.0000000    0
[473,] 0.0000000 0.0000000    0
[474,] 0.0000000 0.0000000    0
[475,] 0.0000000 0.0000000    0
[476,] 0.0000000 0.0000000    0
[477,] 0.0000000 0.0000000    0
[478,] 0.0000000 0.0000000    0
[479,] 0.0000000 0.0000000    0
[480,] 0.0000000 0.0000000    0
[481,] 0.0000000 0.0000000    0
[482,] 0.0000000 0.0000000    0
[483,] 0.0000000 0.0000000    0
[484,] 0.0000000 0.0000000    0
[485,] 0.0000000 0.0000000    0
[486,] 0.0000000 0.0000000    0
[487,] 0.0000000 0.0000000    0
[488,] 0.0000000 0.0000000    0
[489,] 0.0000000 0.0000000    0
[490,] 0.0000000 0.0000000    0
[491,] 0.0000000 0.0000000    0
[492,] 0.0000000 0.0000000    0
[493,] 0.0000000 0.0000000    0
[494,] 0.0000000 0.0000000    0
[495,] 0.0000000 0.0000000    0
[496,] 0.0000000 0.0000000    0
[497,] 0.0000000 0.0000000    0
[498,] 0.0000000 0.0000000    0
[499,] 0.0000000 0.0000000    0
[500,] 0.0000000 0.0000000    0
[501,] 0.0000000 0.0000000    0
[502,] 0.0000000 0.0000000    0
[503,] 0.0000000 0.0000000    0
[504,] 0.0000000 0.0000000    0
[505,] 0.0000000 0.0000000    0
[506,] 0.0000000 0.0000000    0
[507,] 0.0000000 0.0000000    0
[508,] 0.0000000 0.0000000    0
[509,] 0.0000000 0.0000000    0
[510,] 0.0000000 0.0000000    0
[511,] 0.0000000 0.0000000    0
[512,] 0.0000000 0.0000000    0
[513,] 0.0000000 0.0000000    0
[514,] 0.0000000 0.0000000    0
[515,] 0.0000000 0.0000000    0
[516,] 0.0000000 0.0000000    0
[517,] 0.0000000 0.0000000    0
[518,] 0.0000000 0.0000000    0
[519,] 0.0000000 0.0000000    0
[520,] 0.0000000 0.0000000    0
[521,] 0.0000000 0.0000000    0
[522,] 0.0000000 0.0000000    0
[523,] 0.0000000 0.0000000    0
[524,] 0.0000000 0.0000000    0
[525,] 0.0000000 0.0000000    0
[526,] 0.0000000 0.0000000    0
[527,] 0.0000000 0.0000000    0
[528,] 0.0000000 0.0000000    0
[529,] 0.9999307 0.9999307    1
[530,] 0.0000000 0.0000000    0
[531,] 0.0000000 0.0000000    0
[532,] 0.0000000 0.0000000    0
[533,] 0.0000000 0.0000000    0
[534,] 0.0000000 0.0000000    0
[535,] 0.0000000 0.0000000    0
[536,] 0.0000000 0.0000000    0
[537,] 0.0000000 0.0000000    0
[538,] 0.0000000 0.0000000    0
[539,] 0.0000000 0.0000000    0
[540,] 0.0000000 0.0000000    0
[541,] 0.0000000 0.0000000    0
[542,] 0.0000000 0.0000000    0
[543,] 0.0000000 0.0000000    0
[544,] 0.0000000 0.0000000    0
[545,] 0.0000000 0.0000000    0
[546,] 0.0000000 0.0000000    0
[547,] 0.0000000 0.0000000    0
[548,] 0.0000000 0.0000000    0
[549,] 0.0000000 0.0000000    0
[550,] 0.0000000 0.0000000    0
[551,] 0.0000000 0.0000000    0
[552,] 0.0000000 0.0000000    0
[553,] 0.0000000 0.0000000    0
[554,] 0.0000000 0.0000000    0
[555,] 0.0000000 0.0000000    0
[556,] 0.0000000 0.0000000    0
[557,] 0.0000000 0.0000000    0
[558,] 0.0000000 0.0000000    0
[559,] 0.0000000 0.0000000    0
[560,] 0.0000000 0.0000000    0
[561,] 0.0000000 0.0000000    0
[562,] 0.0000000 0.0000000    0
[563,] 0.0000000 0.0000000    0
[564,] 0.0000000 0.0000000    0
[565,] 0.0000000 0.0000000    0
[566,] 0.0000000 0.0000000    0
[567,] 0.0000000 0.0000000    0
[568,] 0.0000000 0.0000000    0
[569,] 0.0000000 0.0000000    0
[570,] 0.0000000 0.0000000    0
[571,] 0.0000000 0.0000000    0
[572,] 0.0000000 0.0000000    0
[573,] 0.0000000 0.0000000    0
[574,] 0.0000000 0.0000000    0
[575,] 0.0000000 0.0000000    0
[576,] 0.0000000 0.0000000    0
[577,] 0.0000000 0.0000000    0
[578,] 0.0000000 0.0000000    0
[579,] 0.0000000 0.0000000    0
[580,] 0.0000000 0.0000000    0
[581,] 0.0000000 0.0000000    0
[582,] 0.0000000 0.0000000    0
[583,] 0.9999858 0.9999858    1
[584,] 0.0000000 0.0000000    0
[585,] 0.0000000 0.0000000    0
[586,] 0.0000000 0.0000000    0
[587,] 0.0000000 0.0000000    0
[588,] 0.0000000 0.0000000    0
[589,] 0.9999203 0.9999203    1
[590,] 0.0000000 0.0000000    0
[591,] 0.0000000 0.0000000    0
[592,] 0.0000000 0.0000000    0
[593,] 0.0000000 0.0000000    0
[594,] 0.0000000 0.0000000    0
[595,] 0.0000000 0.0000000    0
[596,] 0.0000000 0.0000000    0
[597,] 0.0000000 0.0000000    0
[598,] 0.0000000 0.0000000    0
[599,] 0.0000000 0.0000000    0
[600,] 0.0000000 0.0000000    0
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("rem.stat.triad")
> ### * rem.stat.triad
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rem.stat.triad
> ### Title: Compute Triad Closure Statistics for Relational Event Sequences
> ### Aliases: rem.stat.triad
> 
> ### ** Examples
> 
> events <- data.table::data.table(time = 1:18,
+                                 eventID = 1:18,
+                                 sender = c("A", "B", "C",
+                                            "A", "D", "E",
+                                            "F", "B", "A",
+                                            "F", "D", "B",
+                                            "G", "B", "D",
+                                           "H", "A", "D"),
+                                target = c("B", "C", "D",
+                                           "E", "A", "F",
+                                           "D", "A", "C",
+                                           "G", "B", "C",
+                                           "H", "J", "A",
+                                           "F", "C", "B"))
> 
> eventSet <- rem.riskset.om(data = events,
+                       time = events$time,
+                       eventID = events$eventID,
+                       sender = events$sender,
+                       receiver = events$target,
+                       p_samplingobserved = 1.00,
+                       n_controls = 1,
+                       seed = 9999)
> 
> # Computing Triadic Statistics without the sliding windows framework
> eventSet$triadic <- rem.stat.triad(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_sender = events$sender, # variable (column) name that contains the sender variable
+    observed_receiver = events$target, # variable (column) name that contains the receiver variable
+    processed_time = eventSet$time,
+    processed_sender = eventSet$sender,
+    processed_receiver = eventSet$receiver,
+    halflife = 2, #halflife parameter
+    dyadic_weight = 0,
+    Lerneretal_2013 = FALSE)
> 
> # Computing Triadic Statistics with the sliding windows framework
> eventSet$triadicSW <- rem.stat.triad(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_sender = events$sender, # variable (column) name that contains the sender variable
+    observed_receiver = events$target, # variable (column) name that contains the receiver variable
+    processed_time = eventSet$time,
+    processed_sender = eventSet$sender,
+    processed_receiver = eventSet$receiver,
+    halflife = 2, #halflife parameter
+    processed_seqIDs = eventSet$sequenceID,
+    dyadic_weight = 0,
+    sliding_window = TRUE,
+    Lerneretal_2013 = FALSE)
Setting up data structure for the sliding windows framework.......
> 
> #The results with and without the sliding windows are the same (see correlation below).
> #Using the sliding windows method is recommended when the data are 'big' so
> #that memory allotment is more efficient.
> cor(eventSet$triadic , eventSet$triadicSW)
[1] 1
> 
> # Computing Triadic Statistics with the counts of events being returned
> eventSet$triadicC <- rem.stat.triad(
+    observed_time = events$time, # variable (column) name that contains the time variable
+    observed_sender = events$sender, # variable (column) name that contains the sender variable
+    observed_receiver = events$target, # variable (column) name that contains the receiver variable
+    processed_time = eventSet$time,
+    processed_sender = eventSet$sender,
+    processed_receiver = eventSet$receiver,
+    halflife = 2, #halflife parameter
+    dyadic_weight = 0,
+    sliding_window = FALSE,
+    counts = TRUE,
+    Lerneretal_2013 = FALSE)
> 
> cbind(eventSet$triadic,
+      eventSet$triadicSW,
+      eventSet$triadicC)
           [,1]      [,2] [,3]
 [1,] 0.0000000 0.0000000    0
 [2,] 0.0000000 0.0000000    0
 [3,] 0.0000000 0.0000000    0
 [4,] 0.0000000 0.0000000    0
 [5,] 0.0000000 0.0000000    0
 [6,] 0.0000000 0.0000000    0
 [7,] 0.0000000 0.0000000    0
 [8,] 0.0000000 0.0000000    0
 [9,] 0.4204482 0.4204482    1
[10,] 0.0000000 0.0000000    0
[11,] 0.0000000 0.0000000    0
[12,] 0.0000000 0.0000000    0
[13,] 0.3835324 0.3835324    2
[14,] 0.0000000 0.0000000    0
[15,] 0.6123724 0.6123724    2
[16,] 0.3150782 0.3150782    2
[17,] 0.0000000 0.0000000    0
[18,] 0.0000000 0.0000000    0
[19,] 0.0000000 0.0000000    0
[20,] 0.2255273 0.2255273    2
[21,] 0.1575391 0.1575391    2
[22,] 0.3570026 0.3570026    2
[23,] 0.0000000 0.0000000    0
[24,] 0.0000000 0.0000000    0
[25,] 0.4621158 0.4621158    2
[26,] 0.0000000 0.0000000    0
[27,] 0.1486509 0.1486509    1
[28,] 0.1612555 0.1612555    2
[29,] 0.2973018 0.2973018    1
[30,] 0.2102241 0.2102241    1
[31,] 0.3317052 0.3317052    2
[32,] 0.1131242 0.1131242    3
[33,] 0.1619445 0.1619445    3
[34,] 0.1145120 0.1145120    3
[35,] 0.1767767 0.1767767    1
> 
> 
> 
> cleanEx()
> nameEx("tm.constraint")
> ### * tm.constraint
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tm.constraint
> ### Title: Compute Burchard and Cornwell (2018) Two-Mode Constraint
> ### Aliases: tm.constraint
> 
> ### ** Examples
> 
> 
> # For this example, we recreate Figure 2 in Burchard and Cornwell (2018: 13)
> BCNet <- matrix(
+  c(1,1,0,0,
+    1,0,1,0,
+    1,0,0,1,
+    0,1,1,1),
+  nrow = 4, ncol = 4, byrow = TRUE)
> colnames(BCNet) <- c("1", "2", "3", "4")
> rownames(BCNet) <- c("i", "j", "k", "m")
> #library(sna) #To plot the two mode network, we use the sna R package
> #gplot(BCNet, usearrows = FALSE,
> #      gmode = "twomode", displaylabels = TRUE)
> tm.constraint(BCNet)
        i         j         k         m 
0.7500000 0.7500000 0.7500000 0.3333333 
> 
> #For this example, we recreate Figure 9 in Burchard and Cornwell (2018:18) for
> #weighted two mode networks.
> BCweighted <- matrix(c(1,2,1, 1,0,0,
+                       0,2,1,0,0,1),
+                     nrow = 4, ncol = 3,
+                     byrow = TRUE)
> rownames(BCweighted) <- c("i", "j", "k", "l")
> tm.constraint(BCweighted, weighted = TRUE)
        i         j         k         l 
0.8888889 1.0000000 1.7500000 2.0000000 
> 
> 
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("tm.degree")
> ### * tm.degree
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tm.degree
> ### Title: Compute Degree Centrality Values for Two-Mode Networks
> ### Aliases: tm.degree
> 
> ### ** Examples
> 
> #Replicating the biparitate graph presented in Knoke and Yang (2020: 109)
> knoke_yang_PC <- matrix(c(1,1,0,0, 1,1,0,0,
+                           1,1,1,0, 0,0,1,1,
+                           0,0,1,1), byrow = TRUE,
+                           nrow = 5, ncol = 4)
> colnames(knoke_yang_PC) <- c("Rubio-R","McConnell-R", "Reid-D", "Sanders-D")
> rownames(knoke_yang_PC) <- c("UPS", "MS", "HD", "SEU", "ANA")
> tm.degree(knoke_yang_PC, level1 = TRUE) #note: this value matches that of the book
UPS  MS  HD SEU ANA 
  2   2   4   2   2 
> tm.degree(knoke_yang_PC, level1 = FALSE) #note: this value matches that of the book
    Rubio-R McConnell-R      Reid-D   Sanders-D 
          2           2           3           1 
> 
> 
> 
> cleanEx()
> nameEx("tm.density")
> ### * tm.density
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tm.density
> ### Title: Compute Density for Two-Mode Networks
> ### Aliases: tm.density
> 
> ### ** Examples
> 
> #Replicating the biparitate graph presented in Knoke and Yang (2020: 109)
> knoke_yang_PC <- matrix(c(1,1,0,0, 1,1,0,0,
+                           1,1,1,0, 0,0,1,1,
+                           0,0,1,1), byrow = TRUE,
+                           nrow = 5, ncol = 4)
> colnames(knoke_yang_PC) <- c("Rubio-R","McConnell-R", "Reid-D", "Sanders-D")
> rownames(knoke_yang_PC) <- c("UPS", "MS", "HD", "SEU", "ANA")
> tm.density(knoke_yang_PC, level1 = TRUE) #note: this value does not match that of the book,
[1] 1
>                                   #but does match that of Wasserman and Faust (1995: 317)
>                                   #for the ceo dataset.
> tm.density(knoke_yang_PC, level1 = FALSE) #note: this value matches that of the book
[1] 1.166667
> 
> 
> 
> 
> cleanEx()
> nameEx("tm.effective")
> ### * tm.effective
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tm.effective
> ### Title: Compute Burchard and Cornwell (2018) Two-Mode Effective Size
> ### Aliases: tm.effective
> 
> ### ** Examples
> 
> 
> # For this example, we recreate Figure 2 in Burchard and Cornwell (2018: 13)
> BCNet <- matrix(
+  c(1,1,0,0,
+    1,0,1,0,
+    1,0,0,1,
+    0,1,1,1),
+  nrow = 4, ncol = 4, byrow = TRUE)
> colnames(BCNet) <- c("1", "2", "3", "4")
> rownames(BCNet) <- c("i", "j", "k", "m")
> #library(sna) #To plot the two mode network, we use the sna R package
> #gplot(BCNet, usearrows = FALSE,
> #      gmode = "twomode", displaylabels = TRUE)
> tm.effective(BCNet)
       i        j        k        m 
2.333333 2.333333 2.333333 3.000000 
> 
> #For this example, we recreate Figure 9 in Burchard and Cornwell (2018:18) f
> #or weighted two mode networks.
> BCweighted <- matrix(c(1,2,1, 1,0,0,
+                       0,2,1,0,0,1),
+                       nrow = 4, ncol = 3,
+                       byrow = TRUE)
> rownames(BCweighted) <- c("i", "j", "k", "l")
> tm.effective(BCweighted, weighted = TRUE)
       i        j        k        l 
2.444444 1.000000 1.166667 1.000000 
> 
> 
> 
> 
> cleanEx()
> nameEx("tm.homo4cycles")
> ### * tm.homo4cycles
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tm.homo4cycles
> ### Title: Compute Homophlious Four Cycles in Two-Mode Networks
> ### Aliases: tm.homo4cycles
> 
> ### ** Examples
> 
> 
> # For this example, we use the Davis Southern Women's Dataset.
> data("southern.women")
> #creating a random binary membership vector
> set.seed(9999)
> membership <- sample(0:1, nrow(southern.women), replace = TRUE)
> #the homophilous four-cycle values
> tm.homo4cycles(southern.women, mem = membership)
   EVELYN     LAURA   THERESA    BRENDA CHARLOTTE   FRANCES   ELEANOR     PEARL 
       34        33        26        23        12        17        18        11 
     RUTH     VERNE      MYRA KATHERINE    SYLVIA      NORA     HELEN   DOROTHY 
       17        10        18        14        34        26        15        18 
   OLIVIA     FLORA 
        1         1 
> 
> 
> 
> cleanEx()
> nameEx("tm.homoDis")
> ### * tm.homoDis
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tm.homoDis
> ### Title: Compute Ego Homophily Distance in Two-Mode Networks
> ### Aliases: tm.homoDis
> 
> ### ** Examples
> 
> 
> # For this example, we use the Davis Southern Women's Dataset.
> data("southern.women")
> #creating a random binary membership vector
> set.seed(9999)
> membership <- sample(0:1, nrow(southern.women), replace = TRUE)
> #the ego 2 mode distance non-standardized
> tm.homoDis(southern.women, mem = membership)
 [1] 3.846553 3.745543 2.611011 2.247375 1.796825 2.301099 2.345543 1.875125
 [9] 2.176712 1.449106 2.260839 1.871329 3.371950 3.470851 2.618803 2.260839
[17] 1.030303 1.030303
> #the ego 2 mode distance standardized
> tm.homoDis(southern.women, mem = membership, standardize = TRUE)
   EVELYN     LAURA   THERESA    BRENDA CHARLOTTE   FRANCES   ELEANOR     PEARL 
0.4808192 0.5350776 0.3263764 0.3210535 0.4492063 0.5752747 0.5863858 0.6250416 
     RUTH     VERNE      MYRA KATHERINE    SYLVIA      NORA     HELEN   DOROTHY 
0.5441780 0.3622766 0.5652098 0.3118881 0.4817072 0.4338564 0.3741148 0.5652098 
   OLIVIA     FLORA 
0.5151515 0.5151515 
> 
> 
> 
> 
> cleanEx()
> nameEx("tm.redundancy")
> ### * tm.redundancy
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: tm.redundancy
> ### Title: Compute Burchard and Cornwell (2018) Two-Mode Redundancy
> ### Aliases: tm.redundancy
> 
> ### ** Examples
> 
> 
> # For this example, we recreate Figure 2 in Burchard and Cornwell (2018: 13)
> BCNet <- matrix(
+  c(1,1,0,0,
+    1,0,1,0,
+    1,0,0,1,
+    0,1,1,1),
+  nrow = 4, ncol = 4, byrow = TRUE)
> colnames(BCNet) <- c("1", "2", "3", "4")
> rownames(BCNet) <- c("i", "j", "k", "m")
> #library(sna) #To plot the two mode network, we use the sna R package
> #gplot(BCNet, usearrows = FALSE,
> #      gmode = "twomode", displaylabels = TRUE)
> tm.redundancy(BCNet) #this values replicate those reported by Burchard and Cornwell (2018: 14)
          i         j         k m
i 0.0000000 0.3333333 0.3333333 0
j 0.3333333 0.0000000 0.3333333 0
k 0.3333333 0.3333333 0.0000000 0
m 0.0000000 0.0000000 0.0000000 0
> 
> 
> #For this example, we recreate Figure 9 in Burchard and Cornwell (2018:18)
> #for weighted two mode networks.
> BCweighted <- matrix(c(1,2,1, 1,0,0,
+                       0,2,1,0,0,1),
+                       nrow = 4, ncol = 3,
+                       byrow = TRUE)
> rownames(BCweighted) <- c("i", "j", "k", "l")
> tm.redundancy(BCweighted, weighted = TRUE)
          i  j         k         l
i 0.0000000  0 0.2222222 0.3333333
j 0.0000000  0        NA        NA
k 0.3333333 NA 0.0000000 0.5000000
l 0.5000000 NA 0.5000000 0.0000000
> 
> 
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  20.573 6.17 23.811 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
